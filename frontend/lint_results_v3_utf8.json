[{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\algorithms\\SortingAlgorithms.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\algorithms\\SortingAlgorithms.tsx:44:9\n  42 |\n  43 |     useEffect(() => {\n> 44 |         handleGenerateArray();\n     |         ^^^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  45 |     }, [algorithm]);\n  46 |\n  47 |     useEffect(() => {","line":44,"column":9,"nodeType":null,"endLine":44,"endColumn":28},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleGenerateArray'. Either include it or remove the dependency array.","line":45,"column":8,"nodeType":"ArrayExpression","endLine":45,"endColumn":19,"suggestions":[{"desc":"Update the dependencies array to be: [algorithm, handleGenerateArray]","fix":{"range":[1701,1712],"text":"[algorithm, handleGenerateArray]"}}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\algorithms\\SortingAlgorithms.tsx:54:13\n  52 |             }, 50); // Fast speed for algorithms\n  53 |         } else if (currentStep >= history.length - 1) {\n> 54 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  55 |         }\n  56 |         return () => {\n  57 |             if (interval) clearInterval(interval);","line":54,"column":13,"nodeType":null,"endLine":54,"endColumn":25},{"ruleId":"prefer-const","severity":2,"message":"'key' is never reassigned. Use 'const' instead.","line":168,"column":17,"nodeType":"Identifier","messageId":"useConst","endLine":168,"endColumn":20,"fix":{"range":[6473,6490],"text":"const key = arr[i];"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { BaseVisualizer } from '../dataStructures/BaseVisualizer';\r\nimport { Play, RotateCcw } from 'lucide-react';\r\nimport { motion } from 'framer-motion';\r\n\r\ninterface SortingState {\r\n    array: number[];\r\n    comparedIndices: number[]; // Indices currently being compared\r\n    swappedIndices: number[]; // Indices just swapped\r\n    sortedIndices: number[]; // Indices that are fully sorted\r\n    message: string;\r\n}\r\n\r\nexport const SortingAlgorithms = () => {\r\n    const [history, setHistory] = useState<SortingState[]>([\r\n        { array: [], comparedIndices: [], swappedIndices: [], sortedIndices: [], message: 'Start by generating a random array.' }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n    const [algorithm, setAlgorithm] = useState<'bubble' | 'selection' | 'insertion'>('bubble');\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    const handleGenerateArray = () => {\r\n        const newArr = Array.from({ length: 20 }, () => Math.floor(Math.random() * 80) + 10);\r\n        setHistory([{\r\n            array: newArr,\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: [],\r\n            message: `Generated random array on ${algorithm === 'insertion' ? 'Insertion' : algorithm === 'bubble' ? 'Bubble' : 'Selection'} Sort.`\r\n        }]);\r\n        setCurrentStep(0);\r\n        setIsPlaying(false);\r\n    };\r\n\r\n    const addToHistory = (steps: SortingState[]) => {\r\n        setHistory(steps);\r\n        setCurrentStep(0);\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    useEffect(() => {\r\n        handleGenerateArray();\r\n    }, [algorithm]);\r\n\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 50); // Fast speed for algorithms\r\n        } else if (currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const runBubbleSort = (arr: number[]) => {\r\n        const steps: SortingState[] = [];\r\n        steps.push({ array: [...arr], comparedIndices: [], swappedIndices: [], sortedIndices: [], message: 'Starting Bubble Sort...' });\r\n\r\n        for (let i = 0; i < arr.length; i++) {\r\n            for (let j = 0; j < arr.length - i - 1; j++) {\r\n                steps.push({\r\n                    array: [...arr],\r\n                    comparedIndices: [j, j + 1],\r\n                    swappedIndices: [],\r\n                    sortedIndices: Array.from({ length: i }, (_, k) => arr.length - 1 - k),\r\n                    message: `Comparing ${arr[j]} and ${arr[j + 1]}`\r\n                });\r\n\r\n                if (arr[j] > arr[j + 1]) {\r\n                    [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\r\n                    steps.push({\r\n                        array: [...arr],\r\n                        comparedIndices: [j, j + 1],\r\n                        swappedIndices: [j, j + 1],\r\n                        sortedIndices: Array.from({ length: i }, (_, k) => arr.length - 1 - k),\r\n                        message: `Swapped ${arr[j]} and ${arr[j + 1]}`\r\n                    });\r\n                }\r\n            }\r\n            steps.push({\r\n                array: [...arr],\r\n                comparedIndices: [],\r\n                swappedIndices: [],\r\n                sortedIndices: Array.from({ length: i + 1 }, (_, k) => arr.length - 1 - k),\r\n                message: `Pass complete.`\r\n            });\r\n        }\r\n\r\n        steps.push({\r\n            array: [...arr],\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: arr.map((_, i) => i),\r\n            message: 'Bubble Sort Complete.'\r\n        });\r\n        return steps;\r\n    };\r\n\r\n    const runSelectionSort = (arr: number[]) => {\r\n        const steps: SortingState[] = [];\r\n        steps.push({ array: [...arr], comparedIndices: [], swappedIndices: [], sortedIndices: [], message: 'Starting Selection Sort...' });\r\n\r\n        for (let i = 0; i < arr.length; i++) {\r\n            let minIdx = i;\r\n\r\n            for (let j = i + 1; j < arr.length; j++) {\r\n                steps.push({\r\n                    array: [...arr],\r\n                    comparedIndices: [minIdx, j],\r\n                    swappedIndices: [],\r\n                    sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                    message: `Checking ${arr[j]} < ${arr[minIdx]}`\r\n                });\r\n\r\n                if (arr[j] < arr[minIdx]) {\r\n                    minIdx = j;\r\n                    steps.push({\r\n                        array: [...arr],\r\n                        comparedIndices: [minIdx],\r\n                        swappedIndices: [],\r\n                        sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                        message: `New min found: ${arr[minIdx]}`\r\n                    });\r\n                }\r\n            }\r\n\r\n            if (minIdx !== i) {\r\n                [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\r\n                steps.push({\r\n                    array: [...arr],\r\n                    comparedIndices: [i, minIdx],\r\n                    swappedIndices: [i, minIdx],\r\n                    sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                    message: `Swapped min to position ${i}`\r\n                });\r\n            }\r\n\r\n            steps.push({\r\n                array: [...arr],\r\n                comparedIndices: [],\r\n                swappedIndices: [],\r\n                sortedIndices: Array.from({ length: i + 1 }, (_, k) => k),\r\n                message: `Index ${i} sorted.`\r\n            });\r\n        }\r\n\r\n        steps.push({\r\n            array: [...arr],\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: arr.map((_, i) => i),\r\n            message: 'Selection Sort Complete.'\r\n        });\r\n        return steps;\r\n    };\r\n\r\n    const runInsertionSort = (arr: number[]) => {\r\n        const steps: SortingState[] = [];\r\n        steps.push({ array: [...arr], comparedIndices: [], swappedIndices: [], sortedIndices: [0], message: 'Starting Insertion Sort...' });\r\n\r\n        for (let i = 1; i < arr.length; i++) {\r\n            let key = arr[i];\r\n            let j = i - 1;\r\n\r\n            steps.push({\r\n                array: [...arr],\r\n                comparedIndices: [i],\r\n                swappedIndices: [],\r\n                sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                message: `Selecting ${key} to insert into sorted portion.`\r\n            });\r\n\r\n            while (j >= 0 && arr[j] > key) {\r\n                steps.push({\r\n                    array: [...arr],\r\n                    comparedIndices: [j, j + 1],\r\n                    swappedIndices: [],\r\n                    sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                    message: `Comparing ${key} with ${arr[j]} (> ${key}). Shifting ${arr[j]} right.`\r\n                });\r\n\r\n                arr[j + 1] = arr[j];\r\n\r\n                steps.push({\r\n                    array: [...arr],\r\n                    comparedIndices: [j, j + 1],\r\n                    swappedIndices: [j + 1],\r\n                    sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                    message: `Shifted.`\r\n                });\r\n\r\n                j = j - 1;\r\n            }\r\n            arr[j + 1] = key;\r\n\r\n            steps.push({\r\n                array: [...arr],\r\n                comparedIndices: [j + 1],\r\n                swappedIndices: [j + 1],\r\n                sortedIndices: Array.from({ length: i + 1 }, (_, k) => k),\r\n                message: `Inserted ${key} at position ${j + 1}.`\r\n            });\r\n        }\r\n\r\n        steps.push({\r\n            array: [...arr],\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: arr.map((_, i) => i),\r\n            message: 'Insertion Sort Complete.'\r\n        });\r\n        return steps;\r\n    };\r\n\r\n    const handleSort = () => {\r\n        const arr = [...currentState.array];\r\n        let steps: SortingState[] = [];\r\n\r\n        if (algorithm === 'bubble') steps = runBubbleSort(arr);\r\n        else if (algorithm === 'selection') steps = runSelectionSort(arr);\r\n        else if (algorithm === 'insertion') steps = runInsertionSort(arr);\r\n\r\n        addToHistory(steps);\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Sorting Algorithms\"\r\n            description=\"Visualize Bubble, Selection, and Insertion Sort.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={100} // This is just initial, BaseViz controls speed usually if wired up\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-6 w-full max-w-4xl\">\r\n                <div className=\"flex items-center gap-2 bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n                    <button onClick={handleGenerateArray} className=\"flex items-center gap-1 bg-gray-100 text-gray-700 px-3 py-1 rounded text-sm hover:bg-gray-200 transition-colors\">\r\n                        <RotateCcw className=\"w-3 h-3\" /> Randomize\r\n                    </button>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 mx-2\"></div>\r\n\r\n                    <select\r\n                        value={algorithm}\r\n                        onChange={(e) => setAlgorithm(e.target.value as 'bubble' | 'selection' | 'insertion')}\r\n                        className=\"px-2 py-1 border rounded text-sm\"\r\n                    >\r\n                        <option value=\"bubble\">Bubble Sort</option>\r\n                        <option value=\"selection\">Selection Sort</option>\r\n                        <option value=\"insertion\">Insertion Sort</option>\r\n                    </select>\r\n\r\n                    <button onClick={handleSort} className=\"flex items-center gap-1 bg-indigo-600 text-white px-3 py-1 rounded text-sm hover:bg-indigo-700 transition-colors\">\r\n                        <Play className=\"w-3 h-3\" /> Sort\r\n                    </button>\r\n                </div>\r\n\r\n                <div className=\"flex items-end justify-center gap-1 h-[300px] w-full bg-slate-50 border rounded-lg p-4\">\r\n                    <motion.div className=\"flex items-end justify-center gap-1 w-full h-full\">\r\n                        {currentState?.array.map((val, idx) => {\r\n                            const isCompared = currentState.comparedIndices.includes(idx);\r\n                            const isSwapped = currentState.swappedIndices.includes(idx);\r\n                            const isSorted = currentState.sortedIndices.includes(idx);\r\n\r\n                            return (\r\n                                <motion.div\r\n                                    key={idx} // Using index as key for bars in this simple viz is often cleaner for color transitions unless we physically move DOM nodes. \r\n                                    // For Insertion sort, we are checking values shifting. If we want perfect movement, we need unique IDs.\r\n                                    // But for 20+ randomly generated bars, index-key with value-height animation is standardized and performant.\r\n                                    layout\r\n                                    transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                    className=\"flex-1 rounded-t-sm relative group\"\r\n                                    style={{\r\n                                        height: `${val}%`, // Percentage height for responsiveness\r\n                                        backgroundColor: isSwapped ? '#ef4444' : isSorted ? '#10b981' : isCompared ? '#eab308' : '#6366f1',\r\n                                        // opacity: isSorted ? 0.5 : 1 // maybe verify sorted part visually\r\n                                    }}\r\n                                >\r\n                                    {/* Tooltip */}\r\n                                    <div className=\"opacity-0 group-hover:opacity-100 absolute -top-8 left-1/2 -translate-x-1/2 bg-black text-white text-xs px-2 py-1 rounded pointer-events-none\">\r\n                                        {val}\r\n                                    </div>\r\n                                </motion.div>\r\n                            );\r\n                        })}\r\n                    </motion.div>\r\n                </div>\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\BaseVisualizer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\Controls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\array\\ArrayVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\array\\ArrayVisualizer.tsx:31:13\n  29 |             }, 1000);\n  30 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 31 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  32 |         }\n  33 |         return () => {\n  34 |             if (interval) clearInterval(interval);","line":31,"column":13,"nodeType":null,"endLine":31,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Plus, Trash2, Edit, Play } from 'lucide-react';\r\n\r\ninterface ArrayState {\r\n    items: number[];\r\n    message: string;\r\n    activeIndices: number[]; // For highlighting during traversal or operations\r\n}\r\n\r\nexport const ArrayVisualizer = () => {\r\n    const [history, setHistory] = useState<ArrayState[]>([\r\n        { items: [10, 20, 30, 40], message: 'Initial Array.', activeIndices: [] }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [indexValue, setIndexValue] = useState('0');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    // Playback Logic\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: ArrayState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const parseInput = () => {\r\n        const val = parseInt(inputValue);\r\n        const idx = parseInt(indexValue);\r\n        if (isNaN(val) || isNaN(idx)) return null;\r\n        return { val, idx };\r\n    };\r\n\r\n    const handleInsert = () => {\r\n        const inputs = parseInput();\r\n        if (!inputs) return;\r\n        const { val, idx } = inputs;\r\n\r\n        if (idx < 0 || idx > currentState.items.length) {\r\n            alert(\"Index out of bounds!\");\r\n            return;\r\n        }\r\n        if (currentState.items.length >= 8) {\r\n            alert(\"Array full! Max 8 items.\");\r\n            return;\r\n        }\r\n\r\n        const newItems = [...currentState.items];\r\n        newItems.splice(idx, 0, val);\r\n\r\n        addToHistory({\r\n            items: newItems,\r\n            message: `Inserted ${val} at index ${idx}. Elements shifted right.`,\r\n            activeIndices: [idx]\r\n        });\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleDelete = () => {\r\n        const idx = parseInt(indexValue);\r\n        if (isNaN(idx) || idx < 0 || idx >= currentState.items.length) {\r\n            alert(\"Invalid Index!\");\r\n            return;\r\n        }\r\n\r\n        const item = currentState.items[idx];\r\n        const newItems = [...currentState.items];\r\n        newItems.splice(idx, 1);\r\n\r\n        addToHistory({\r\n            items: newItems,\r\n            message: `Deleted ${item} from index ${idx}. Elements shifted left.`,\r\n            activeIndices: [] // Highlighting handled by exit animation mostly\r\n        });\r\n    };\r\n\r\n    const handleUpdate = () => {\r\n        const inputs = parseInput();\r\n        if (!inputs) return;\r\n        const { val, idx } = inputs;\r\n\r\n        if (idx < 0 || idx >= currentState.items.length) {\r\n            alert(\"Index out of bounds!\");\r\n            return;\r\n        }\r\n\r\n        const newItems = [...currentState.items];\r\n        newItems[idx] = val;\r\n\r\n        addToHistory({\r\n            items: newItems,\r\n            message: `Updated index ${idx} to ${val}.`,\r\n            activeIndices: [idx]\r\n        });\r\n        setInputValue('');\r\n    };\r\n\r\n    // Traversal is a multi-step operation, usually best handled by generating multiple history steps automatically\r\n    const handleTraverse = () => {\r\n        if (currentState.items.length === 0) return;\r\n\r\n        // We will generate N steps and add them all to history immediately\r\n        const steps: ArrayState[] = [];\r\n        const baseItems = currentState.items;\r\n\r\n        for (let i = 0; i < baseItems.length; i++) {\r\n            steps.push({\r\n                items: baseItems,\r\n                message: `Traversing: Visited index ${i} (Value: ${baseItems[i]})`,\r\n                activeIndices: [i]\r\n            });\r\n        }\r\n\r\n        // Append last step clearing highlight\r\n        steps.push({\r\n            items: baseItems,\r\n            message: 'Traversal Complete.',\r\n            activeIndices: []\r\n        });\r\n\r\n        const newHistory = [...history.slice(0, currentStep + 1), ...steps];\r\n        setHistory(newHistory);\r\n        // Auto-play the traversal\r\n        setCurrentStep(currentStep + 1); // Start first step\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Array Visualization\"\r\n            description=\"Fundamental linear data structure with contiguous memory locations.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-3xl\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex flex-wrap items-center justify-center gap-4 w-full bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Val\"\r\n                            className=\"w-16 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                        <span className=\"text-gray-400\">@</span>\r\n                        <input\r\n                            type=\"number\"\r\n                            value={indexValue}\r\n                            onChange={(e) => setIndexValue(e.target.value)}\r\n                            placeholder=\"Idx\"\r\n                            className=\"w-14 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                    </div>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 hidden md:block\"></div>\r\n\r\n                    <div className=\"flex gap-2\">\r\n                        <button onClick={handleInsert} className=\"flex items-center gap-1 bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs hover:bg-blue-200 transition-colors\">\r\n                            <Plus className=\"w-3 h-3\" /> Ins\r\n                        </button>\r\n                        <button onClick={handleUpdate} className=\"flex items-center gap-1 bg-green-100 text-green-700 px-2 py-1 rounded text-xs hover:bg-green-200 transition-colors\">\r\n                            <Edit className=\"w-3 h-3\" /> Upd\r\n                        </button>\r\n                        <button onClick={handleDelete} className=\"flex items-center gap-1 bg-red-100 text-red-700 px-2 py-1 rounded text-xs hover:bg-red-200 transition-colors\">\r\n                            <Trash2 className=\"w-3 h-3\" /> Del\r\n                        </button>\r\n                    </div>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 hidden md:block\"></div>\r\n\r\n                    <button onClick={handleTraverse} className=\"flex items-center gap-1 bg-purple-100 text-purple-700 px-3 py-1 rounded text-xs hover:bg-purple-200 transition-colors\">\r\n                        <Play className=\"w-3 h-3\" /> Traverse\r\n                    </button>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                <div className=\"flex items-center justify-center w-full min-h-[120px] bg-gray-50/50 rounded-lg p-8\">\r\n                    <div className=\"flex items-center gap-1\">\r\n                        <AnimatePresence mode=\"popLayout\">\r\n                            {currentState.items.map((item, index) => (\r\n                                <motion.div\r\n                                    key={index}\r\n                                    layout\r\n                                    initial={{ opacity: 0, scale: 0.8, y: -20 }}\r\n                                    animate={{\r\n                                        opacity: 1,\r\n\r\n                                        y: 0,\r\n                                        backgroundColor: currentState.activeIndices.includes(index) ? '#dbeafe' : '#ffffff',\r\n                                        borderColor: currentState.activeIndices.includes(index) ? '#2563eb' : '#e5e7eb',\r\n                                        scale: currentState.activeIndices.includes(index) ? 1.1 : 1\r\n                                    }}\r\n                                    exit={{ opacity: 0, scale: 0.8, y: 20 }}\r\n                                    transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                    className=\"w-14 h-14 flex flex-col items-center justify-center rounded-md border-2 shadow-sm text-lg font-bold text-gray-700 relative bg-white\"\r\n                                >\r\n                                    {item}\r\n                                    <span className=\"absolute -bottom-6 text-[10px] text-gray-400 font-normal\">\r\n                                        {index}\r\n                                    </span>\r\n                                </motion.div>\r\n                            ))}\r\n                        </AnimatePresence>\r\n\r\n                        {currentState.items.length === 0 && (\r\n                            <div className=\"text-gray-300 text-sm pointer-events-none\">\r\n                                Empty Array\r\n                            </div>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\circularLinkedList\\CircularLinkedListVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\circularLinkedList\\CircularLinkedListVisualizer.tsx:35:13\n  33 |             }, 1000);\n  34 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 35 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  36 |         }\n  37 |         return () => {\n  38 |             if (interval) clearInterval(interval);","line":35,"column":13,"nodeType":null,"endLine":35,"endColumn":25},{"ruleId":"prefer-const","severity":2,"message":"'newNodes' is never reassigned. Use 'const' instead.","line":63,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":63,"endColumn":21,"fix":{"range":[2155,2194],"text":"const newNodes = [...currentState.nodes];"}},{"ruleId":"prefer-const","severity":2,"message":"'newNodes' is never reassigned. Use 'const' instead.","line":101,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":101,"endColumn":21,"fix":{"range":[3479,3518],"text":"const newNodes = [...currentState.nodes];"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { ArrowRight, CornerDownLeft } from 'lucide-react';\r\n\r\ninterface ListNode {\r\n    id: string;\r\n    value: number;\r\n}\r\n\r\ninterface CircularLinkedListState {\r\n    nodes: ListNode[];\r\n    message: string;\r\n    activeIndices: number[];\r\n}\r\n\r\nexport const CircularLinkedListVisualizer = () => {\r\n    const [history, setHistory] = useState<CircularLinkedListState[]>([\r\n        { nodes: [{ id: 'init-10', value: 10 }, { id: 'init-20', value: 20 }], message: 'Initial Circular Linked List.', activeIndices: [] }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [indexValue, setIndexValue] = useState('0');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: CircularLinkedListState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const getInputs = () => {\r\n        const val = parseInt(inputValue);\r\n        const idx = parseInt(indexValue);\r\n        return { val, idx };\r\n    };\r\n\r\n    const handleInsert = (position: 'head' | 'tail' | 'index') => {\r\n        const { val, idx } = getInputs();\r\n        if (isNaN(val)) return;\r\n\r\n        if (currentState.nodes.length >= 7) {\r\n            alert(\"List full! Max 7 nodes.\");\r\n            return;\r\n        }\r\n\r\n        let newNodes = [...currentState.nodes];\r\n        const newNode = { id: `node-${Date.now()}`, value: val };\r\n\r\n        if (position === 'head') {\r\n            newNodes.unshift(newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at Head. Tail's next points to new Head.`,\r\n                activeIndices: [0]\r\n            });\r\n        } else if (position === 'tail') {\r\n            newNodes.push(newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at Tail. New Tail points to Head.`,\r\n                activeIndices: [newNodes.length - 1]\r\n            });\r\n        } else {\r\n            if (isNaN(idx) || idx < 0 || idx > currentState.nodes.length) {\r\n                alert(\"Invalid index\");\r\n                return;\r\n            }\r\n            newNodes.splice(idx, 0, newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at index ${idx}.`,\r\n                activeIndices: [idx]\r\n            });\r\n        }\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleDelete = (position: 'head' | 'tail' | 'index') => {\r\n        if (currentState.nodes.length === 0) {\r\n            alert(\"List empty!\");\r\n            return;\r\n        }\r\n\r\n        let newNodes = [...currentState.nodes];\r\n        let removedVal;\r\n\r\n        if (position === 'head') {\r\n            removedVal = newNodes.shift()?.value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted Head (${removedVal}). Tail's next updated to new Head.`,\r\n                activeIndices: []\r\n            });\r\n        } else if (position === 'tail') {\r\n            removedVal = newNodes.pop()?.value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted Tail (${removedVal}). New Tail points to Head.`,\r\n                activeIndices: []\r\n            });\r\n        } else {\r\n            const { idx } = getInputs();\r\n            if (isNaN(idx) || idx < 0 || idx >= currentState.nodes.length) {\r\n                alert(\"Invalid index\");\r\n                return;\r\n            }\r\n            removedVal = newNodes.splice(idx, 1)[0].value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted index ${idx} (${removedVal}).`,\r\n                activeIndices: []\r\n            });\r\n        }\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Circular Linked List\"\r\n            description=\"Singly Linked List where the last node points back to the first node.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-4xl\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex flex-wrap items-center justify-center gap-4 w-full bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Val\"\r\n                            className=\"w-16 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                        <span className=\"text-gray-400\">@</span>\r\n                        <input\r\n                            type=\"number\"\r\n                            value={indexValue}\r\n                            onChange={(e) => setIndexValue(e.target.value)}\r\n                            placeholder=\"Idx\"\r\n                            className=\"w-14 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                    </div>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 hidden md:block\"></div>\r\n\r\n                    <div className=\"flex flex-col gap-1\">\r\n                        <div className=\"flex gap-1\">\r\n                            <button onClick={() => handleInsert('head')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Head</button>\r\n                            <button onClick={() => handleInsert('tail')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Tail</button>\r\n                            <button onClick={() => handleInsert('index')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Idx</button>\r\n                        </div>\r\n                        <div className=\"flex gap-1\">\r\n                            <button onClick={() => handleDelete('head')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Head</button>\r\n                            <button onClick={() => handleDelete('tail')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Tail</button>\r\n                            <button onClick={() => handleDelete('index')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Idx</button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                <div className=\"flex items-center justify-start w-full min-h-[180px] bg-gray-50/50 rounded-lg p-8 overflow-x-auto relative\">\r\n                    <div className=\"flex items-center min-w-max relative pl-4\">\r\n                        <AnimatePresence mode=\"popLayout\">\r\n                            {currentState.nodes.map((node, index) => (\r\n                                <div key={node.id} className=\"flex items-center\">\r\n                                    {/* Node */}\r\n                                    <motion.div\r\n                                        layout\r\n                                        initial={{ opacity: 0, scale: 0.8, y: -20 }}\r\n                                        animate={{\r\n                                            opacity: 1,\r\n                                            scale: 1,\r\n                                            y: 0,\r\n                                            backgroundColor: currentState.activeIndices.includes(index) ? '#dbeafe' : '#ffffff',\r\n                                            borderColor: currentState.activeIndices.includes(index) ? '#2563eb' : '#e5e7eb'\r\n                                        }}\r\n                                        exit={{ opacity: 0, scale: 0.5, y: 20 }}\r\n                                        transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                        className=\"w-24 h-12 flex rounded border-2 shadow-sm bg-white overflow-hidden z-10\"\r\n                                    >\r\n                                        <div className=\"flex-1 flex items-center justify-center font-bold text-gray-700 border-r border-gray-200\">\r\n                                            {node.value}\r\n                                        </div>\r\n                                        <div className=\"w-8 flex items-center justify-center bg-gray-50 text-gray-400 text-[10px]\">\r\n                                            ΓÇó\r\n                                        </div>\r\n                                    </motion.div>\r\n\r\n                                    {/* Arrow Connection */}\r\n                                    {index < currentState.nodes.length - 1 && (\r\n                                        <motion.div\r\n                                            layout\r\n                                            className=\"mx-2 text-gray-400\"\r\n                                        >\r\n                                            <ArrowRight className=\"w-5 h-5\" />\r\n                                        </motion.div>\r\n                                    )}\r\n                                </div>\r\n                            ))}\r\n                        </AnimatePresence>\r\n\r\n                        {/* Visual loop back to start */}\r\n                        {currentState.nodes.length > 0 ? (\r\n                            <motion.div\r\n                                initial={{ opacity: 0 }}\r\n                                animate={{ opacity: 1 }}\r\n                                className=\"ml-2 flex items-center\"\r\n                            >\r\n                                <div className=\"relative\">\r\n                                    <ArrowRight className=\"w-5 h-5 text-purple-400\" />\r\n                                    {/* Dotted line loop back - purely visual CSS hack for now or just an indicator */}\r\n                                    <div className=\"absolute top-1/2 left-full w-4 h-0.5 bg-purple-400\"></div>\r\n                                    <div className=\"absolute top-1/2 left-[calc(100%+16px)] w-[1px] h-20 bg-purple-400 origin-top\"></div>\r\n                                    <CornerDownLeft className=\"absolute top-[80px] -left-[200%] text-purple-400 w-5 h-5\" /> {/* This is static, doesn't stretch. Real loop needs SVG. */}\r\n                                    <span className=\"text-[10px] text-purple-500 font-bold ml-1 absolute -top-4 w-20\">To Head</span>\r\n                                </div>\r\n                            </motion.div>\r\n                        ) : (\r\n                            <div className=\"w-full text-center text-gray-300 pointer-events-none\">Empty List</div>\r\n                        )}\r\n\r\n                        {/* Better loop visualization using SVG overlay */}\r\n                        {currentState.nodes.length > 0 && (\r\n                            <div className=\"absolute inset-x-0 bottom-0 top-1/2 pointer-events-none z-0\">\r\n                                {/* We can use an SVG line that goes from last node position to first. \r\n                             Hard to exact coordinate without refs. \r\n                             For simple visual, we can just show a \"Loop\" text or arrow at the end. */}\r\n                            </div>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\circularQueue\\CircularQueueVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\circularQueue\\CircularQueueVisualizer.tsx:42:13\n  40 |             }, 1000);\n  41 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 42 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  43 |         }\n  44 |         return () => {\n  45 |             if (interval) clearInterval(interval);","line":42,"column":13,"nodeType":null,"endLine":42,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Plus, Trash2 } from 'lucide-react';\r\n\r\nconst CAPACITY = 8;\r\nconst RADIUS = 120; // px\r\nconst CENTER = 150; // px\r\n\r\ninterface CircularQueueState {\r\n    items: (number | null)[]; // Fixed size array\r\n    front: number;\r\n    rear: number;\r\n    size: number;\r\n    message: string;\r\n}\r\n\r\nexport const CircularQueueVisualizer = () => {\r\n    const [history, setHistory] = useState<CircularQueueState[]>([\r\n        {\r\n            items: Array(CAPACITY).fill(null),\r\n            front: -1,\r\n            rear: -1,\r\n            size: 0,\r\n            message: 'Circular Queue empty. Capacity: 8.'\r\n        }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    // Playback Logic\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: CircularQueueState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const handleEnqueue = () => {\r\n        if (!inputValue) return;\r\n        const num = parseInt(inputValue);\r\n        if (isNaN(num)) return;\r\n\r\n        if ((currentState.rear + 1) % CAPACITY === currentState.front) {\r\n            // Queue is full is mostly defined as size === capacity, \r\n            // but in circular queue implementation often we keep one slot empty strictly or use size count.\r\n            // Here we track 'size', so full is size === CAPACITY\r\n        }\r\n\r\n        if (currentState.size === CAPACITY) {\r\n            addToHistory({ ...currentState, message: 'Queue Overflow! Buffer is full.' });\r\n            return;\r\n        }\r\n\r\n        const nextRear = (currentState.rear + 1) % CAPACITY;\r\n        const nextFront = currentState.front === -1 ? 0 : currentState.front;\r\n\r\n        const newItems = [...currentState.items];\r\n        newItems[nextRear] = num;\r\n\r\n        addToHistory({\r\n            items: newItems,\r\n            front: nextFront,\r\n            rear: nextRear,\r\n            size: currentState.size + 1,\r\n            message: `Enqueued ${num} at index ${nextRear}.`\r\n        });\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleDequeue = () => {\r\n        if (currentState.size === 0) {\r\n            addToHistory({ ...currentState, message: 'Queue Underflow! Buffer is empty.' });\r\n            return;\r\n        }\r\n\r\n        const removedItem = currentState.items[currentState.front];\r\n        const newItems = [...currentState.items];\r\n        newItems[currentState.front] = null; // Visually remove\r\n\r\n        if (currentState.front === currentState.rear) {\r\n            // Last element removed\r\n            addToHistory({\r\n                items: newItems,\r\n                front: -1,\r\n                rear: -1,\r\n                size: 0,\r\n                message: `Dequeued ${removedItem}. Queue is now empty.`\r\n            });\r\n        } else {\r\n            const nextFront = (currentState.front + 1) % CAPACITY;\r\n            addToHistory({\r\n                items: newItems,\r\n                front: nextFront,\r\n                rear: currentState.rear,\r\n                size: currentState.size - 1,\r\n                message: `Dequeued ${removedItem} from index ${currentState.front}. Front moves to ${nextFront}.`\r\n            });\r\n        }\r\n    };\r\n\r\n    // Helper to calculate position on circle\r\n    const getPosition = (index: number) => {\r\n        const angle = (index / CAPACITY) * 2 * Math.PI - Math.PI / 2; // Start from top (-90deg)\r\n        return {\r\n            x: CENTER + RADIUS * Math.cos(angle),\r\n            y: CENTER + RADIUS * Math.sin(angle)\r\n        };\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Circular Queue Visualization\"\r\n            description=\"Connects the end of the queue back to the start to utilize empty space efficiently.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-2xl\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex gap-2 w-full max-w-md bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n                    <div className=\"flex-1 flex gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Value\"\r\n                            className=\"w-20 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                            onKeyDown={(e) => e.key === 'Enter' && handleEnqueue()}\r\n                        />\r\n                        <button onClick={handleEnqueue} className=\"flex-1 flex items-center justify-center gap-1 bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 transition-colors\">\r\n                            <Plus className=\"w-3 h-3\" /> Enqueue\r\n                        </button>\r\n                    </div>\r\n\r\n                    <button onClick={handleDequeue} className=\"flex items-center gap-1 bg-red-100 text-red-700 px-3 py-1 rounded text-sm hover:bg-red-200 transition-colors\">\r\n                        <Trash2 className=\"w-3 h-3\" /> Dequeue\r\n                    </button>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                <div className=\"relative w-[300px] h-[300px] bg-slate-50/50 rounded-full border border-slate-100 mx-auto\">\r\n                    {/* Slots */}\r\n                    {Array.from({ length: CAPACITY }).map((_, i) => {\r\n                        const pos = getPosition(i);\r\n                        const isFront = i === currentState.front;\r\n                        const isRear = i === currentState.rear;\r\n                        const hasItem = currentState.items[i] !== null;\r\n\r\n                        return (\r\n                            <div\r\n                                key={i}\r\n                                className=\"absolute w-12 h-12 -ml-6 -mt-6 flex items-center justify-center rounded-full border-2 transition-all duration-300\"\r\n                                style={{\r\n                                    left: pos.x,\r\n                                    top: pos.y,\r\n                                    backgroundColor: hasItem ? 'white' : 'transparent',\r\n                                    borderColor: hasItem ? '#3b82f6' : '#e5e7eb',\r\n                                    borderStyle: hasItem ? 'solid' : 'dashed'\r\n                                }}\r\n                            >\r\n                                <span className=\"text-sm font-bold text-gray-700\">\r\n                                    {currentState.items[i]}\r\n                                </span>\r\n\r\n                                {/* Index Label */}\r\n                                <span className=\"absolute -top-5 text-[10px] text-gray-400\">\r\n                                    {i}\r\n                                </span>\r\n\r\n                                {/* Pointers */}\r\n                                {isFront && currentState.size > 0 && (\r\n                                    <motion.div\r\n                                        layoutId=\"front-pointer\"\r\n                                        className=\"absolute -left-8 bg-red-100 text-red-700 text-[10px] font-bold px-1.5 py-0.5 rounded shadow-sm border border-red-200\"\r\n                                    >\r\n                                        F\r\n                                    </motion.div>\r\n                                )}\r\n                                {isRear && currentState.size > 0 && (\r\n                                    <motion.div\r\n                                        layoutId=\"rear-pointer\"\r\n                                        className=\"absolute -right-8 bg-blue-100 text-blue-700 text-[10px] font-bold px-1.5 py-0.5 rounded shadow-sm border border-blue-200\"\r\n                                    >\r\n                                        R\r\n                                    </motion.div>\r\n                                )}\r\n                            </div>\r\n                        );\r\n                    })}\r\n\r\n                    {/* Center Info */}\r\n                    <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none\">\r\n                        <div className=\"text-center text-xs text-gray-400\">\r\n                            <div>Size: {currentState.size}</div>\r\n                            <div>Capacity: {CAPACITY}</div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\deque\\DequeVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\deque\\DequeVisualizer.tsx:29:13\n  27 |             }, 1000);\n  28 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 29 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  30 |         }\n  31 |         return () => {\n  32 |             if (interval) clearInterval(interval);","line":29,"column":13,"nodeType":null,"endLine":29,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Plus, Trash2, ArrowRight, ArrowLeft } from 'lucide-react';\r\n\r\ninterface DequeState {\r\n    items: number[];\r\n    message: string;\r\n}\r\n\r\nexport const DequeVisualizer = () => {\r\n    const [history, setHistory] = useState<DequeState[]>([\r\n        { items: [], message: 'Deque is empty. You can insert at Front or Rear.' }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    // Playback Logic\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: DequeState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const handleInsertFront = () => {\r\n        if (!inputValue) return;\r\n        const num = parseInt(inputValue);\r\n        if (isNaN(num)) return;\r\n\r\n        if (currentState.items.length >= 7) {\r\n            alert(\"Deque full! Max 7 items for visualization.\");\r\n            return;\r\n        }\r\n\r\n        addToHistory({\r\n            items: [num, ...currentState.items],\r\n            message: `Inserted ${num} at the Front.`\r\n        });\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleInsertRear = () => {\r\n        if (!inputValue) return;\r\n        const num = parseInt(inputValue);\r\n        if (isNaN(num)) return;\r\n\r\n        if (currentState.items.length >= 7) {\r\n            alert(\"Deque full! Max 7 items for visualization.\");\r\n            return;\r\n        }\r\n\r\n        addToHistory({\r\n            items: [...currentState.items, num],\r\n            message: `Inserted ${num} at the Rear.`\r\n        });\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleDeleteFront = () => {\r\n        if (currentState.items.length === 0) {\r\n            addToHistory({\r\n                items: [],\r\n                message: 'Underflow! Cannot delete from empty Deque.'\r\n            });\r\n            return;\r\n        }\r\n\r\n        const [removed, ...rest] = currentState.items;\r\n        addToHistory({\r\n            items: rest,\r\n            message: `Deleted ${removed} from the Front.`\r\n        });\r\n    };\r\n\r\n    const handleDeleteRear = () => {\r\n        if (currentState.items.length === 0) {\r\n            addToHistory({\r\n                items: [],\r\n                message: 'Underflow! Cannot delete from empty Deque.'\r\n            });\r\n            return;\r\n        }\r\n\r\n        const newItems = [...currentState.items];\r\n        const removed = newItems.pop();\r\n        addToHistory({\r\n            items: newItems,\r\n            message: `Deleted ${removed} from the Rear.`\r\n        });\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Deque Visualization\"\r\n            description=\"Double-Ended Queue allows insertion and deletion from both ends.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-3xl\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex flex-col md:flex-row gap-4 w-full bg-white p-4 rounded-lg shadow-sm border border-gray-200 justify-center\">\r\n\r\n                    <div className=\"flex gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Val\"\r\n                            className=\"w-16 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                        <div className=\"flex flex-col gap-1\">\r\n                            <button onClick={handleInsertFront} className=\"flex items-center gap-1 bg-green-100 text-green-700 px-2 py-1 rounded text-xs hover:bg-green-200 transition-colors\">\r\n                                <Plus className=\"w-3 h-3\" /> Front\r\n                            </button>\r\n                            <button onClick={handleInsertRear} className=\"flex items-center gap-1 bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs hover:bg-blue-200 transition-colors\">\r\n                                <Plus className=\"w-3 h-3\" /> Rear\r\n                            </button>\r\n                        </div>\r\n                    </div>\r\n\r\n                    <div className=\"w-px bg-gray-200 mx-2 hidden md:block\"></div>\r\n\r\n                    <div className=\"flex flex-col gap-1\">\r\n                        <button onClick={handleDeleteFront} className=\"flex items-center gap-1 bg-red-100 text-red-700 px-2 py-1 rounded text-xs hover:bg-red-200 transition-colors\">\r\n                            <Trash2 className=\"w-3 h-3\" /> Front\r\n                        </button>\r\n                        <button onClick={handleDeleteRear} className=\"flex items-center gap-1 bg-orange-100 text-orange-700 px-2 py-1 rounded text-xs hover:bg-orange-200 transition-colors\">\r\n                            <Trash2 className=\"w-3 h-3\" /> Rear\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                <div className=\"flex items-center justify-center w-full min-h-[120px] bg-gray-50/50 rounded-lg p-8 relative overflow-hidden\">\r\n\r\n                    {/* Labels */}\r\n                    {currentState.items.length > 0 && (\r\n                        <>\r\n                            <div className=\"absolute left-8 top-1/2 -translate-y-1/2 text-xs font-bold text-green-600 -rotate-90 origin-center flex items-center gap-1\">\r\n                                <ArrowLeft className=\"w-3 h-3 rotate-90\" /> FRONT\r\n                            </div>\r\n                            <div className=\"absolute right-8 top-1/2 -translate-y-1/2 text-xs font-bold text-blue-600 -rotate-90 origin-center flex items-center gap-1\">\r\n                                REAR <ArrowRight className=\"w-3 h-3 rotate-90\" />\r\n                            </div>\r\n                        </>\r\n                    )}\r\n\r\n                    <div className=\"flex items-center gap-2 border-t-2 border-b-2 border-dashed border-gray-300 px-8 py-4 min-w-[200px] justify-center\">\r\n                        <AnimatePresence mode=\"popLayout\">\r\n                            {currentState.items.map((item, index) => (\r\n                                <motion.div\r\n                                    key={`${item}-${index}-${currentState.items.length}`} // Ensure uniqueness for animations\r\n                                    layout\r\n                                    initial={{ opacity: 0, scale: 0.8, y: -20 }}\r\n                                    animate={{\r\n                                        opacity: 1,\r\n                                        scale: 1,\r\n                                        y: 0,\r\n                                        backgroundColor: '#ffffff',\r\n                                        borderColor: '#e5e7eb'\r\n                                    }}\r\n                                    exit={{ opacity: 0, scale: 0.8, y: 20, backgroundColor: '#fee2e2' }}\r\n                                    transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                    className=\"w-12 h-12 flex items-center justify-center rounded-md border-2 shadow-sm text-lg font-bold text-gray-700 relative bg-white min-w-[3rem]\"\r\n                                >\r\n                                    {item}\r\n                                </motion.div>\r\n                            ))}\r\n                        </AnimatePresence>\r\n\r\n                        {currentState.items.length === 0 && (\r\n                            <div className=\"text-gray-300 text-sm pointer-events-none absolute inset-0 flex items-center justify-center\">\r\n                                Empty Deque\r\n                            </div>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\doublyLinkedList\\DoublyLinkedListVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\doublyLinkedList\\DoublyLinkedListVisualizer.tsx:35:13\n  33 |             }, 1000);\n  34 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 35 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  36 |         }\n  37 |         return () => {\n  38 |             if (interval) clearInterval(interval);","line":35,"column":13,"nodeType":null,"endLine":35,"endColumn":25},{"ruleId":"prefer-const","severity":2,"message":"'newNodes' is never reassigned. Use 'const' instead.","line":63,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":63,"endColumn":21,"fix":{"range":[2140,2179],"text":"const newNodes = [...currentState.nodes];"}},{"ruleId":"prefer-const","severity":2,"message":"'newNodes' is never reassigned. Use 'const' instead.","line":101,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":101,"endColumn":21,"fix":{"range":[3492,3531],"text":"const newNodes = [...currentState.nodes];"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { ArrowLeft, ArrowRight } from 'lucide-react';\r\n\r\ninterface ListNode {\r\n    id: string;\r\n    value: number;\r\n}\r\n\r\ninterface DoublyLinkedListState {\r\n    nodes: ListNode[];\r\n    message: string;\r\n    activeIndices: number[];\r\n}\r\n\r\nexport const DoublyLinkedListVisualizer = () => {\r\n    const [history, setHistory] = useState<DoublyLinkedListState[]>([\r\n        { nodes: [{ id: 'init-10', value: 10 }, { id: 'init-20', value: 20 }], message: 'Initial Doubly Linked List.', activeIndices: [] }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [indexValue, setIndexValue] = useState('0');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: DoublyLinkedListState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const getInputs = () => {\r\n        const val = parseInt(inputValue);\r\n        const idx = parseInt(indexValue);\r\n        return { val, idx };\r\n    };\r\n\r\n    const handleInsert = (position: 'head' | 'tail' | 'index') => {\r\n        const { val, idx } = getInputs();\r\n        if (isNaN(val)) return;\r\n\r\n        if (currentState.nodes.length >= 7) {\r\n            alert(\"List full! Max 7 nodes.\");\r\n            return;\r\n        }\r\n\r\n        let newNodes = [...currentState.nodes];\r\n        const newNode = { id: `node-${Date.now()}`, value: val };\r\n\r\n        if (position === 'head') {\r\n            newNodes.unshift(newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at Head. Updated Prev/Next pointers.`,\r\n                activeIndices: [0]\r\n            });\r\n        } else if (position === 'tail') {\r\n            newNodes.push(newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at Tail. Updated Prev/Next pointers.`,\r\n                activeIndices: [newNodes.length - 1]\r\n            });\r\n        } else {\r\n            if (isNaN(idx) || idx < 0 || idx > currentState.nodes.length) {\r\n                alert(\"Invalid index\");\r\n                return;\r\n            }\r\n            newNodes.splice(idx, 0, newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at index ${idx}. Updated bidirectional links.`,\r\n                activeIndices: [idx]\r\n            });\r\n        }\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleDelete = (position: 'head' | 'tail' | 'index') => {\r\n        if (currentState.nodes.length === 0) {\r\n            alert(\"List empty!\");\r\n            return;\r\n        }\r\n\r\n        let newNodes = [...currentState.nodes];\r\n        let removedVal;\r\n\r\n        if (position === 'head') {\r\n            removedVal = newNodes.shift()?.value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted Head (${removedVal}).`,\r\n                activeIndices: []\r\n            });\r\n        } else if (position === 'tail') {\r\n            removedVal = newNodes.pop()?.value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted Tail (${removedVal}).`,\r\n                activeIndices: []\r\n            });\r\n        } else {\r\n            const { idx } = getInputs();\r\n            if (isNaN(idx) || idx < 0 || idx >= currentState.nodes.length) {\r\n                alert(\"Invalid index\");\r\n                return;\r\n            }\r\n            removedVal = newNodes.splice(idx, 1)[0].value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted index ${idx} (${removedVal}).`,\r\n                activeIndices: []\r\n            });\r\n        }\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Doubly Linked List\"\r\n            description=\"Nodes containing data and pointers to both previous and next nodes.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-4xl\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex flex-wrap items-center justify-center gap-4 w-full bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Val\"\r\n                            className=\"w-16 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                        <span className=\"text-gray-400\">@</span>\r\n                        <input\r\n                            type=\"number\"\r\n                            value={indexValue}\r\n                            onChange={(e) => setIndexValue(e.target.value)}\r\n                            placeholder=\"Idx\"\r\n                            className=\"w-14 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                    </div>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 hidden md:block\"></div>\r\n\r\n                    <div className=\"flex flex-col gap-1\">\r\n                        <div className=\"flex gap-1\">\r\n                            <button onClick={() => handleInsert('head')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Head</button>\r\n                            <button onClick={() => handleInsert('tail')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Tail</button>\r\n                            <button onClick={() => handleInsert('index')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Idx</button>\r\n                        </div>\r\n                        <div className=\"flex gap-1\">\r\n                            <button onClick={() => handleDelete('head')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Head</button>\r\n                            <button onClick={() => handleDelete('tail')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Tail</button>\r\n                            <button onClick={() => handleDelete('index')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Idx</button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                <div className=\"flex items-center justify-start w-full min-h-[160px] bg-gray-50/50 rounded-lg p-8 overflow-x-auto\">\r\n                    <div className=\"flex items-center min-w-max\">\r\n\r\n                        {/* NULL Terminator (Prev) */}\r\n                        <div className=\"text-xs font-bold text-gray-400 mr-2\">NULL</div>\r\n                        <ArrowLeft className=\"w-4 h-4 text-gray-300 mr-2\" />\r\n\r\n                        <AnimatePresence mode=\"popLayout\">\r\n                            {currentState.nodes.map((node, index) => (\r\n                                <div key={node.id} className=\"flex items-center\">\r\n                                    {/* Node */}\r\n                                    <motion.div\r\n                                        layout\r\n                                        initial={{ opacity: 0, scale: 0.8, y: -20 }}\r\n                                        animate={{\r\n                                            opacity: 1,\r\n                                            scale: 1,\r\n                                            y: 0,\r\n                                            backgroundColor: currentState.activeIndices.includes(index) ? '#dbeafe' : '#ffffff',\r\n                                            borderColor: currentState.activeIndices.includes(index) ? '#2563eb' : '#e5e7eb'\r\n                                        }}\r\n                                        exit={{ opacity: 0, scale: 0.5, y: 20 }}\r\n                                        transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                        className=\"w-28 h-12 flex rounded border-2 shadow-sm bg-white overflow-hidden\"\r\n                                    >\r\n                                        {/* Prev Pointer */}\r\n                                        <div className=\"w-6 flex items-center justify-center bg-red-50 text-red-300 border-r border-gray-100 text-[10px]\">\r\n                                            ΓÇó\r\n                                        </div>\r\n                                        {/* Data Part */}\r\n                                        <div className=\"flex-1 flex items-center justify-center font-bold text-gray-700\">\r\n                                            {node.value}\r\n                                        </div>\r\n                                        {/* Next Pointer */}\r\n                                        <div className=\"w-6 flex items-center justify-center bg-blue-50 text-blue-300 border-l border-gray-100 text-[10px]\">\r\n                                            ΓÇó\r\n                                        </div>\r\n                                    </motion.div>\r\n\r\n                                    {/* Arrow Connection */}\r\n                                    {index < currentState.nodes.length && (\r\n                                        <motion.div\r\n                                            layout\r\n                                            className=\"mx-1 flex flex-col gap-0.5\"\r\n                                        >\r\n                                            <ArrowRight className=\"w-4 h-4 text-blue-400\" />\r\n                                            <ArrowLeft className=\"w-4 h-4 text-red-400\" />\r\n                                        </motion.div>\r\n                                    )}\r\n                                </div>\r\n                            ))}\r\n                        </AnimatePresence>\r\n\r\n                        {/* NULL Terminator (Next) */}\r\n                        {currentState.nodes.length > 0 ? (\r\n                            <>\r\n                                <div className=\"text-xs font-bold text-gray-400 ml-2\">NULL</div>\r\n                            </>\r\n                        ) : (\r\n                            <span className=\"text-gray-300 ml-2\">Empty List</span>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\graph\\GraphVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\graph\\GraphVisualizer.tsx:49:13\n  47 |             }, 1000);\n  48 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 49 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  50 |         }\n  51 |         return () => {\n  52 |             if (interval) clearInterval(interval);","line":49,"column":13,"nodeType":null,"endLine":49,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Plus, Play, Share2 } from 'lucide-react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\n\r\ninterface GraphNode {\r\n    id: string; // Label\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\ninterface GraphEdge {\r\n    source: string;\r\n    target: string;\r\n}\r\n\r\ninterface GraphState {\r\n    nodes: GraphNode[];\r\n    edges: GraphEdge[];\r\n    adjList: Record<string, string[]>;\r\n    activeNodes: string[];\r\n    visitedNodes: string[];\r\n    queueStack: string[]; // For BFS Queue or DFS Stack visualization\r\n    message: string;\r\n}\r\n\r\nexport const GraphVisualizer = () => {\r\n    const [history, setHistory] = useState<GraphState[]>([\r\n        { nodes: [], edges: [], adjList: {}, activeNodes: [], visitedNodes: [], queueStack: [], message: 'Graph is empty. Add vertices to start.' }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    // Inputs\r\n    const [vertexLabel, setVertexLabel] = useState('');\r\n    const [edgeSource, setEdgeSource] = useState('');\r\n    const [edgeTarget, setEdgeTarget] = useState('');\r\n    const [startNode, setStartNode] = useState('');\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (steps: GraphState[]) => {\r\n        const base = history.slice(0, currentStep + 1);\r\n        setHistory([...base, ...steps]);\r\n        setCurrentStep(base.length);\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    const handleAddVertex = () => {\r\n        const label = vertexLabel.trim();\r\n        if (!label) return;\r\n        if (currentState.nodes.some(n => n.id === label)) {\r\n            alert(\"Vertex already exists!\");\r\n            return;\r\n        }\r\n\r\n        // Random position within 600x400 canvas, with some padding\r\n        const x = 50 + Math.random() * 500;\r\n        const y = 50 + Math.random() * 300;\r\n\r\n        const newNode: GraphNode = { id: label, x, y };\r\n\r\n        const newState: GraphState = {\r\n            ...currentState,\r\n            nodes: [...currentState.nodes, newNode],\r\n            adjList: { ...currentState.adjList, [label]: [] },\r\n            message: `Added vertex ${label}`\r\n        };\r\n\r\n        addToHistory([newState]);\r\n        setVertexLabel('');\r\n    };\r\n\r\n    const handleAddEdge = () => {\r\n        const u = edgeSource.trim();\r\n        const v = edgeTarget.trim();\r\n\r\n        if (!u || !v) return;\r\n        if (!currentState.nodes.some(n => n.id === u) || !currentState.nodes.some(n => n.id === v)) {\r\n            alert(\"Both vertices must exist.\");\r\n            return;\r\n        }\r\n        if (currentState.edges.some(e => (e.source === u && e.target === v) || (e.source === v && e.target === u))) {\r\n            alert(\"Edge already exists.\");\r\n            return;\r\n        }\r\n\r\n        const newEdge: GraphEdge = { source: u, target: v };\r\n\r\n        // Undirected graph logic\r\n        const newAdjList = { ...currentState.adjList };\r\n        newAdjList[u] = [...(newAdjList[u] || []), v];\r\n        newAdjList[v] = [...(newAdjList[v] || []), u];\r\n\r\n        const newState: GraphState = {\r\n            ...currentState,\r\n            edges: [...currentState.edges, newEdge],\r\n            adjList: newAdjList,\r\n            message: `Added edge ${u} - ${v}`\r\n        };\r\n\r\n        addToHistory([newState]);\r\n        setEdgeSource('');\r\n        setEdgeTarget('');\r\n    };\r\n\r\n    const handleBFS = () => {\r\n        const start = startNode.trim();\r\n        if (!start || !currentState.nodes.some(n => n.id === start)) return;\r\n\r\n        const steps: GraphState[] = [];\r\n        const visited = new Set<string>();\r\n        const queue: string[] = [start];\r\n        visited.add(start);\r\n\r\n        // Initial Step\r\n        steps.push({\r\n            ...currentState,\r\n            activeNodes: [start],\r\n            visitedNodes: [...Array.from(visited)],\r\n            queueStack: [...queue],\r\n            message: `BFS Start: Initialized queue with ${start}`\r\n        });\r\n\r\n        let head = 0; // Simulate queue dequeue index\r\n        while (head < queue.length) {\r\n            const curr = queue[head];\r\n            head++; // Dequeue\r\n\r\n            steps.push({\r\n                ...currentState,\r\n                activeNodes: [curr],\r\n                visitedNodes: [...Array.from(visited)],\r\n                queueStack: queue.slice(head),\r\n                message: `Dequeued ${curr}. Processing neighbors...`\r\n            });\r\n\r\n            const neighbors = currentState.adjList[curr] || [];\r\n            for (const neighbor of neighbors) {\r\n                if (!visited.has(neighbor)) {\r\n                    visited.add(neighbor);\r\n                    queue.push(neighbor);\r\n\r\n                    steps.push({\r\n                        ...currentState,\r\n                        activeNodes: [curr, neighbor], // Highlight current and neighbor\r\n                        visitedNodes: [...Array.from(visited)],\r\n                        queueStack: queue.slice(head),\r\n                        message: `Visited neighbor ${neighbor}, added to queue.`\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        steps.push({\r\n            ...currentState,\r\n            activeNodes: [],\r\n            visitedNodes: [...Array.from(visited)],\r\n            queueStack: [],\r\n            message: `BFS Complete.`\r\n        });\r\n\r\n        addToHistory(steps);\r\n    };\r\n\r\n    const handleDFS = () => {\r\n        const start = startNode.trim();\r\n        if (!start || !currentState.nodes.some(n => n.id === start)) return;\r\n\r\n        const steps: GraphState[] = [];\r\n        const visited = new Set<string>();\r\n        const stack: string[] = [start];\r\n        // We'll use an iterative DFS for easier state capturing, or recursive with explicit step pushing.\r\n        // Recursive is standard for DFS but iterative is easier to visualize stack. \r\n        // Let's use iterative to visualize the \"Stack\".\r\n\r\n        steps.push({\r\n            ...currentState,\r\n            activeNodes: [],\r\n            visitedNodes: [],\r\n            queueStack: [...stack],\r\n            message: `DFS Start: Pushed ${start} to stack.`\r\n        });\r\n\r\n        while (stack.length > 0) {\r\n            const curr = stack.pop()!;\r\n\r\n            if (!visited.has(curr)) {\r\n                visited.add(curr);\r\n\r\n                steps.push({\r\n                    ...currentState,\r\n                    activeNodes: [curr],\r\n                    visitedNodes: [...Array.from(visited)],\r\n                    queueStack: [...stack],\r\n                    message: `Popped ${curr}. Mark as visited.`\r\n                });\r\n\r\n                const neighbors = currentState.adjList[curr] || [];\r\n                // Reverse to process in natural order if pushed\r\n                for (let i = neighbors.length - 1; i >= 0; i--) {\r\n                    const neighbor = neighbors[i];\r\n                    if (!visited.has(neighbor)) {\r\n                        stack.push(neighbor);\r\n                        steps.push({\r\n                            ...currentState,\r\n                            activeNodes: [curr],\r\n                            visitedNodes: [...Array.from(visited)],\r\n                            queueStack: [...stack],\r\n                            message: `Push neighbor ${neighbor} to stack.`\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        steps.push({\r\n            ...currentState,\r\n            activeNodes: [],\r\n            visitedNodes: [...Array.from(visited)],\r\n            queueStack: [],\r\n            message: `DFS Complete.`\r\n        });\r\n\r\n        addToHistory(steps);\r\n    };\r\n\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Graph\"\r\n            description=\"Network of nodes (vertices) and edges. Supports BFS and DFS.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-6 w-full max-w-4xl\">\r\n                {/* Controls */}\r\n                <div className=\"flex flex-wrap items-center justify-center gap-4 bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n                    {/* Add Vertex */}\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <input\r\n                            type=\"text\"\r\n                            value={vertexLabel}\r\n                            onChange={(e) => setVertexLabel(e.target.value)}\r\n                            placeholder=\"Vertex (e.g. A)\"\r\n                            className=\"w-24 px-2 py-1 border rounded text-sm\"\r\n                        />\r\n                        <button onClick={handleAddVertex} className=\"flex items-center gap-1 bg-blue-600 text-white px-2 py-1 rounded text-sm hover:bg-blue-700\">\r\n                            <Plus className=\"w-3 h-3\" /> Node\r\n                        </button>\r\n                    </div>\r\n                    <div className=\"w-px h-8 bg-gray-200\"></div>\r\n\r\n                    {/* Add Edge */}\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <input\r\n                            type=\"text\"\r\n                            value={edgeSource}\r\n                            onChange={(e) => setEdgeSource(e.target.value)}\r\n                            placeholder=\"Src\"\r\n                            className=\"w-16 px-2 py-1 border rounded text-sm\"\r\n                        />\r\n                        <input\r\n                            type=\"text\"\r\n                            value={edgeTarget}\r\n                            onChange={(e) => setEdgeTarget(e.target.value)}\r\n                            placeholder=\"Tgt\"\r\n                            className=\"w-16 px-2 py-1 border rounded text-sm\"\r\n                        />\r\n                        <button onClick={handleAddEdge} className=\"flex items-center gap-1 bg-indigo-600 text-white px-2 py-1 rounded text-sm hover:bg-indigo-700\">\r\n                            <Share2 className=\"w-3 h-3\" /> Edge\r\n                        </button>\r\n                    </div>\r\n                    <div className=\"w-px h-8 bg-gray-200\"></div>\r\n\r\n                    {/* Algorithms */}\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <input\r\n                            type=\"text\"\r\n                            value={startNode}\r\n                            onChange={(e) => setStartNode(e.target.value)}\r\n                            placeholder=\"Start\"\r\n                            className=\"w-16 px-2 py-1 border rounded text-sm\"\r\n                        />\r\n                        <button onClick={handleBFS} className=\"flex items-center gap-1 bg-green-600 text-white px-2 py-1 rounded text-sm hover:bg-green-700\">\r\n                            <Play className=\"w-3 h-3\" /> BFS\r\n                        </button>\r\n                        <button onClick={handleDFS} className=\"flex items-center gap-1 bg-purple-600 text-white px-2 py-1 rounded text-sm hover:bg-purple-700\">\r\n                            <Play className=\"w-3 h-3\" /> DFS\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"flex gap-8 w-full\">\r\n                    {/* Canvas */}\r\n                    <div className=\"relative w-full h-[400px] border rounded-lg bg-gray-50 overflow-hidden shadow-inner\">\r\n                        <AnimatePresence>\r\n                            {/* Edges */}\r\n                            {currentState.edges.map((edge, idx) => {\r\n                                const u = currentState.nodes.find(n => n.id === edge.source);\r\n                                const v = currentState.nodes.find(n => n.id === edge.target);\r\n                                if (!u || !v) return null;\r\n\r\n                                return (\r\n                                    <motion.svg key={`edge-${idx}`} className=\"absolute top-0 left-0 w-full h-full pointer-events-none\">\r\n                                        <line\r\n                                            x1={u.x}\r\n                                            y1={u.y}\r\n                                            x2={v.x}\r\n                                            y2={v.y}\r\n                                            stroke=\"#94a3b8\"\r\n                                            strokeWidth=\"2\"\r\n                                        />\r\n                                    </motion.svg>\r\n                                );\r\n                            })}\r\n\r\n                            {/* Vertices */}\r\n                            {currentState.nodes.map((node) => {\r\n                                const isVisited = currentState.visitedNodes.includes(node.id);\r\n                                const isActive = currentState.activeNodes.includes(node.id);\r\n\r\n                                return (\r\n                                    <motion.div\r\n                                        key={node.id}\r\n                                        initial={{ scale: 0 }}\r\n                                        animate={{\r\n                                            scale: 1,\r\n                                            backgroundColor: isActive ? '#facc15' : isVisited ? '#4ade80' : '#ffffff',\r\n                                            borderColor: isActive ? '#ca8a04' : isVisited ? '#16a34a' : '#94a3b8',\r\n                                            // Ensure contrast\r\n                                            color: '#1e293b'\r\n                                        }}\r\n                                        className=\"absolute w-10 h-10 -ml-5 -mt-5 flex items-center justify-center rounded-full border-2 font-bold shadow-sm z-10 cursor-default\"\r\n                                        style={{ left: node.x, top: node.y }}\r\n                                    >\r\n                                        {node.id}\r\n                                    </motion.div>\r\n                                );\r\n                            })}\r\n                        </AnimatePresence>\r\n                    </div>\r\n\r\n                    {/* Data Structures View (Queue/Stack) */}\r\n                    <div className=\"w-48 flex flex-col gap-4\">\r\n                        <div className=\"bg-white p-2 rounded border h-full\">\r\n                            <h3 className=\"font-semibold text-sm mb-2 text-center text-gray-700\">Queue / Stack</h3>\r\n                            <div className=\"flex flex-col gap-1\">\r\n                                {currentState.queueStack.map((val, idx) => (\r\n                                    <div key={idx} className=\"bg-gray-100 p-1 text-center rounded text-sm border\">\r\n                                        {val}\r\n                                    </div>\r\n                                ))}\r\n                                {currentState.queueStack.length === 0 && <span className=\"text-xs text-gray-400 text-center italic\">Empty</span>}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\heap\\HeapVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\heap\\HeapVisualizer.tsx:81:13\n  79 |             }, 800);\n  80 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 81 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  82 |         }\n  83 |         return () => {\n  84 |             if (interval) clearInterval(interval);","line":81,"column":13,"nodeType":null,"endLine":81,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Plus, Trash2 } from 'lucide-react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\n\r\ninterface HeapNode {\r\n    id: string;\r\n    value: number;\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\ninterface HeapState {\r\n    array: number[];\r\n    activeIndices: number[];\r\n    shiningIndices: number[]; // For highlighting swap targets\r\n    message: string;\r\n}\r\n\r\nexport const HeapVisualizer = () => {\r\n    const [history, setHistory] = useState<HeapState[]>([\r\n        { array: [], activeIndices: [], shiningIndices: [], message: 'Heap is empty. Insert a value to start.' }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    const generateNodes = (arr: number[]): HeapNode[] => {\r\n        const nodes: HeapNode[] = [];\r\n        if (arr.length === 0) return nodes;\r\n\r\n        const startX = 400;\r\n        const startY = 50;\r\n\r\n        // Using a map to store positions for parent lookup\r\n        const positions = new Map<number, { x: number, y: number }>();\r\n        const levelOffset = 60;\r\n\r\n        arr.forEach((val, i) => {\r\n            if (i === 0) {\r\n                positions.set(i, { x: startX, y: startY });\r\n                nodes.push({ id: `node-${i}-${val}`, value: val, x: startX, y: startY });\r\n            } else {\r\n                const parentIdx = Math.floor((i - 1) / 2);\r\n                const parentPos = positions.get(parentIdx);\r\n                if (parentPos) {\r\n                    const level = Math.floor(Math.log2(i + 1));\r\n                    // Check max depth 4 to avoid clutter\r\n                    // Offset needs to depend on level to avoid overlap\r\n                    // Root level 0. Level 1 offset 100. Level 2 offset 50.\r\n                    // General formula: 200 / 2^level?\r\n                    // Actually, total width is fixed. \r\n                    // Let's try: 200 / (1.8 ^ (level - 1))\r\n\r\n                    const offset = 200 / Math.pow(2, level - 1);\r\n\r\n                    const isLeft = (i % 2) !== 0;\r\n                    const x = isLeft ? parentPos.x - offset : parentPos.x + offset;\r\n                    const y = parentPos.y + levelOffset;\r\n\r\n                    positions.set(i, { x, y });\r\n                    nodes.push({ id: `node-${i}-${val}`, value: val, x, y });\r\n                }\r\n            }\r\n        });\r\n\r\n        return nodes;\r\n    };\r\n\r\n    const renderNodes = generateNodes(currentState.array);\r\n\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 800);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (steps: HeapState[]) => {\r\n        const base = history.slice(0, currentStep + 1);\r\n        setHistory([...base, ...steps]);\r\n        setCurrentStep(base.length);\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    const handleInsert = () => {\r\n        const val = parseInt(inputValue);\r\n        if (isNaN(val)) return;\r\n        if (currentState.array.length >= 15) { // Limit size\r\n            alert(\"Heap full (max 15 nodes for visualizer)\");\r\n            return;\r\n        }\r\n\r\n        const newArr = [...currentState.array, val];\r\n        const steps: HeapState[] = [];\r\n\r\n        // Step 1: Add to end\r\n        steps.push({\r\n            array: [...newArr],\r\n            activeIndices: [newArr.length - 1],\r\n            shiningIndices: [],\r\n            message: `Inserted ${val} at the end.`\r\n        });\r\n\r\n        // Step 2: Heapify Up\r\n        let curr = newArr.length - 1;\r\n        while (curr > 0) {\r\n            const parent = Math.floor((curr - 1) / 2);\r\n\r\n            steps.push({\r\n                array: [...newArr],\r\n                activeIndices: [curr],\r\n                shiningIndices: [parent],\r\n                message: `Comparing ${newArr[curr]} with parent ${newArr[parent]}...`\r\n            });\r\n\r\n            if (newArr[curr] > newArr[parent]) {\r\n                // Swap\r\n                [newArr[curr], newArr[parent]] = [newArr[parent], newArr[curr]];\r\n                steps.push({\r\n                    array: [...newArr],\r\n                    activeIndices: [parent],\r\n                    shiningIndices: [],\r\n                    message: `Swapped: ${newArr[parent]} > ${newArr[curr]}. Moving up.`\r\n                });\r\n                curr = parent;\r\n            } else {\r\n                steps.push({\r\n                    array: [...newArr],\r\n                    activeIndices: [curr],\r\n                    shiningIndices: [],\r\n                    message: `Heap property satisfied (${newArr[curr]} <= ${newArr[parent]}).`\r\n                });\r\n                break;\r\n            }\r\n        }\r\n\r\n        steps.push({\r\n            array: [...newArr],\r\n            activeIndices: [],\r\n            shiningIndices: [],\r\n            message: `Insert complete.`\r\n        });\r\n\r\n        addToHistory(steps);\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleDelete = () => { // Extract Max\r\n        if (currentState.array.length === 0) return;\r\n\r\n        const newArr = [...currentState.array];\r\n        const steps: HeapState[] = [];\r\n        const maxVal = newArr[0];\r\n\r\n        // Step 1: Highlight root\r\n        steps.push({\r\n            array: [...newArr],\r\n            activeIndices: [0],\r\n            shiningIndices: [],\r\n            message: `Extracting max value: ${maxVal}`\r\n        });\r\n\r\n        const lastVal = newArr.pop()!; // Remove last\r\n\r\n        if (newArr.length > 0) {\r\n            // Move last to root\r\n            newArr[0] = lastVal;\r\n            steps.push({\r\n                array: [...newArr],\r\n                activeIndices: [0],\r\n                shiningIndices: [],\r\n                message: `Moved last element (${lastVal}) to root.`\r\n            });\r\n\r\n            // Heapify Down\r\n            let curr = 0;\r\n            while (true) {\r\n                const left = 2 * curr + 1;\r\n                const right = 2 * curr + 2;\r\n                let largest = curr;\r\n\r\n                if (left < newArr.length && newArr[left] > newArr[largest]) {\r\n                    largest = left;\r\n                }\r\n                if (right < newArr.length && newArr[right] > newArr[largest]) {\r\n                    largest = right;\r\n                }\r\n\r\n                if (largest !== curr) {\r\n                    steps.push({\r\n                        array: [...newArr],\r\n                        activeIndices: [curr],\r\n                        shiningIndices: [largest],\r\n                        message: `Comparing with children... ${newArr[largest]} is larger.`\r\n                    });\r\n\r\n                    // Swap\r\n                    [newArr[curr], newArr[largest]] = [newArr[largest], newArr[curr]];\r\n\r\n                    steps.push({\r\n                        array: [...newArr],\r\n                        activeIndices: [largest],\r\n                        shiningIndices: [],\r\n                        message: `Swapped with ${newArr[largest]}. Moving down.`\r\n                    });\r\n\r\n                    curr = largest;\r\n                } else {\r\n                    steps.push({\r\n                        array: [...newArr],\r\n                        activeIndices: [curr],\r\n                        shiningIndices: [],\r\n                        message: `Heap property satisfied.`\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            steps.push({\r\n                array: [],\r\n                activeIndices: [],\r\n                shiningIndices: [],\r\n                message: `Heap is now empty.`\r\n            });\r\n        }\r\n\r\n        steps.push({\r\n            array: [...newArr],\r\n            activeIndices: [],\r\n            shiningIndices: [],\r\n            message: `Extract Max Complete.`\r\n        });\r\n\r\n        addToHistory(steps);\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Max Heap\"\r\n            description=\"Complete Binary Tree where Parent >= Children. Root is Max.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={800}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-4xl\">\r\n                <div className=\"flex items-center gap-2 bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n                    <input\r\n                        type=\"number\"\r\n                        value={inputValue}\r\n                        onChange={(e) => setInputValue(e.target.value)}\r\n                        placeholder=\"Val\"\r\n                        className=\"w-20 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        onKeyDown={(e) => e.key === 'Enter' && handleInsert()}\r\n                    />\r\n                    <button onClick={handleInsert} className=\"flex items-center gap-1 bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 transition-colors\">\r\n                        <Plus className=\"w-3 h-3\" /> Insert\r\n                    </button>\r\n                    <button onClick={handleDelete} className=\"flex items-center gap-1 bg-red-600 text-white px-3 py-1 rounded text-sm hover:bg-red-700 transition-colors\">\r\n                        <Trash2 className=\"w-3 h-3\" /> Extract Max\r\n                    </button>\r\n                </div>\r\n\r\n                <div className=\"relative w-full h-[400px] border rounded-lg bg-gray-50 overflow-hidden flex justify-center pt-8\">\r\n                    <AnimatePresence>\r\n                        {/* Edges */}\r\n                        {renderNodes.map(node => {\r\n                            // Find parent to draw edge\r\n                            const nodeIdx = parseInt(node.id.split('-')[1]);\r\n                            if (nodeIdx === 0) return null;\r\n                            const parentIdx = Math.floor((nodeIdx - 1) / 2);\r\n                            const parent = renderNodes.find(n => parseInt(n.id.split('-')[1]) === parentIdx);\r\n                            if (!parent) return null;\r\n\r\n                            return (\r\n                                <motion.svg key={`edge-${node.id}`} className=\"absolute top-0 left-0 w-full h-full pointer-events-none\" style={{ zIndex: 0 }}>\r\n                                    <line\r\n                                        x1={parent.x}\r\n                                        y1={parent.y}\r\n                                        x2={node.x}\r\n                                        y2={node.y}\r\n                                        stroke=\"#cbd5e1\"\r\n                                        strokeWidth=\"2\"\r\n                                    />\r\n                                </motion.svg>\r\n                            );\r\n                        })}\r\n\r\n                        {/* Nodes */}\r\n                        {renderNodes.map((node) => {\r\n                            // find real index from id\r\n                            const realIndex = parseInt(node.id.split('-')[1]);\r\n                            const isActive = currentState.activeIndices.includes(realIndex);\r\n                            const isShining = currentState.shiningIndices.includes(realIndex);\r\n\r\n                            return (\r\n                                <motion.div\r\n                                    key={node.id} // Stable key\r\n                                    initial={{ scale: 0, opacity: 0 }}\r\n                                    animate={{\r\n                                        scale: 1,\r\n                                        opacity: 1,\r\n                                        x: node.x - 20, // Center the 40px div\r\n                                        y: node.y - 20,\r\n                                        backgroundColor: isActive ? '#3b82f6' : isShining ? '#fbbf24' : '#ffffff',\r\n                                        color: isActive ? '#ffffff' : '#1e293b',\r\n                                        borderColor: isActive ? '#2563eb' : isShining ? '#d97706' : '#94a3b8'\r\n                                    }}\r\n                                    exit={{ scale: 0, opacity: 0 }}\r\n                                    transition={{ duration: 0.5 }}\r\n                                    className=\"absolute flex items-center justify-center w-10 h-10 rounded-full border-2 shadow-sm font-bold z-10\"\r\n                                >\r\n                                    {node.value}\r\n                                </motion.div>\r\n                            );\r\n                        })}\r\n                    </AnimatePresence>\r\n                </div>\r\n\r\n                {/* Array view */}\r\n                <div className=\"flex gap-1 flex-wrap justify-center p-4 bg-gray-50 rounded w-full\">\r\n                    {currentState.array.map((val, idx) => (\r\n                        <div key={idx} className={`border p-2 min-w-[30px] text-center ${currentState.activeIndices.includes(idx) ? 'bg-blue-200' : 'bg-white'}`}>\r\n                            <div className=\"text-xs text-gray-500 mb-1\">{idx}</div>\r\n                            <div className=\"font-semibold\">{val}</div>\r\n                        </div>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\linkedList\\SinglyLinkedListVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\linkedList\\SinglyLinkedListVisualizer.tsx:36:13\n  34 |             }, 1000);\n  35 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 36 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  37 |         }\n  38 |         return () => {\n  39 |             if (interval) clearInterval(interval);","line":36,"column":13,"nodeType":null,"endLine":36,"endColumn":25},{"ruleId":"prefer-const","severity":2,"message":"'newNodes' is never reassigned. Use 'const' instead.","line":64,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":64,"endColumn":21,"fix":{"range":[2202,2241],"text":"const newNodes = [...currentState.nodes];"}},{"ruleId":"prefer-const","severity":2,"message":"'newNodes' is never reassigned. Use 'const' instead.","line":103,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":103,"endColumn":21,"fix":{"range":[3471,3510],"text":"const newNodes = [...currentState.nodes];"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { ArrowRight } from 'lucide-react';\r\n\r\ninterface ListNode {\r\n    id: string; // Unique ID for animations\r\n    value: number;\r\n}\r\n\r\ninterface LinkedListState {\r\n    nodes: ListNode[];\r\n    message: string;\r\n    activeIndices: number[]; // Indices currently being visited/highlighted\r\n}\r\n\r\nexport const SinglyLinkedListVisualizer = () => {\r\n    const [history, setHistory] = useState<LinkedListState[]>([\r\n        { nodes: [{ id: 'init-10', value: 10 }, { id: 'init-20', value: 20 }], message: 'Initial Linked List.', activeIndices: [] }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [indexValue, setIndexValue] = useState('0');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    // Playback Logic\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: LinkedListState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const getInputs = () => {\r\n        const val = parseInt(inputValue);\r\n        const idx = parseInt(indexValue);\r\n        return { val, idx };\r\n    };\r\n\r\n    const handleInsert = (position: 'head' | 'tail' | 'index') => {\r\n        const { val, idx } = getInputs();\r\n        if (isNaN(val)) return;\r\n\r\n        if (currentState.nodes.length >= 7) {\r\n            alert(\"List full! Max 7 nodes.\");\r\n            return;\r\n        }\r\n\r\n        let newNodes = [...currentState.nodes];\r\n        const newNode = { id: `node-${Date.now()}`, value: val };\r\n\r\n        if (position === 'head') {\r\n            newNodes.unshift(newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at Head.`,\r\n                activeIndices: [0]\r\n            });\r\n        } else if (position === 'tail') {\r\n            newNodes.push(newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at Tail.`,\r\n                activeIndices: [newNodes.length - 1]\r\n            });\r\n        } else {\r\n            if (isNaN(idx) || idx < 0 || idx > currentState.nodes.length) {\r\n                alert(\"Invalid index\");\r\n                return;\r\n            }\r\n            newNodes.splice(idx, 0, newNode);\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Inserted ${val} at index ${idx}.`,\r\n                activeIndices: [idx]\r\n            });\r\n        }\r\n        setInputValue('');\r\n    };\r\n\r\n\r\n    const handleDelete = (position: 'head' | 'tail' | 'index') => {\r\n        if (currentState.nodes.length === 0) {\r\n            alert(\"List empty!\");\r\n            return;\r\n        }\r\n\r\n        let newNodes = [...currentState.nodes];\r\n        let removedVal;\r\n\r\n        if (position === 'head') {\r\n            removedVal = newNodes.shift()?.value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted Head (${removedVal}).`,\r\n                activeIndices: []\r\n            });\r\n        } else if (position === 'tail') {\r\n            removedVal = newNodes.pop()?.value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted Tail (${removedVal}).`,\r\n                activeIndices: []\r\n            });\r\n        } else {\r\n            const { idx } = getInputs();\r\n            if (isNaN(idx) || idx < 0 || idx >= currentState.nodes.length) {\r\n                alert(\"Invalid index\");\r\n                return;\r\n            }\r\n            removedVal = newNodes.splice(idx, 1)[0].value;\r\n            addToHistory({\r\n                nodes: newNodes,\r\n                message: `Deleted index ${idx} (${removedVal}).`,\r\n                activeIndices: []\r\n            });\r\n        }\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Singly Linked List\"\r\n            description=\"Linear collection of nodes where each node points to the next.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-4xl\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex flex-wrap items-center justify-center gap-4 w-full bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Val\"\r\n                            className=\"w-16 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                        <span className=\"text-gray-400\">@</span>\r\n                        <input\r\n                            type=\"number\"\r\n                            value={indexValue}\r\n                            onChange={(e) => setIndexValue(e.target.value)}\r\n                            placeholder=\"Idx\"\r\n                            className=\"w-14 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                        />\r\n                    </div>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 hidden md:block\"></div>\r\n\r\n                    <div className=\"flex flex-col gap-1\">\r\n                        <div className=\"flex gap-1\">\r\n                            <button onClick={() => handleInsert('head')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Head</button>\r\n                            <button onClick={() => handleInsert('tail')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Tail</button>\r\n                            <button onClick={() => handleInsert('index')} className=\"px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200\">Add Idx</button>\r\n                        </div>\r\n                        <div className=\"flex gap-1\">\r\n                            <button onClick={() => handleDelete('head')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Head</button>\r\n                            <button onClick={() => handleDelete('tail')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Tail</button>\r\n                            <button onClick={() => handleDelete('index')} className=\"px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200\">Del Idx</button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                <div className=\"flex items-center justify-start w-full min-h-[160px] bg-gray-50/50 rounded-lg p-8 overflow-x-auto\">\r\n                    <div className=\"flex items-center min-w-max\">\r\n                        <AnimatePresence mode=\"popLayout\">\r\n                            {currentState.nodes.map((node, index) => (\r\n                                <div key={node.id} className=\"flex items-center\">\r\n                                    {/* Node */}\r\n                                    <motion.div\r\n                                        layout\r\n                                        initial={{ opacity: 0, scale: 0.8, y: -20 }}\r\n                                        animate={{\r\n                                            opacity: 1,\r\n                                            scale: 1,\r\n                                            y: 0,\r\n                                            backgroundColor: currentState.activeIndices.includes(index) ? '#dbeafe' : '#ffffff',\r\n                                            borderColor: currentState.activeIndices.includes(index) ? '#2563eb' : '#e5e7eb'\r\n                                        }}\r\n                                        exit={{ opacity: 0, scale: 0.5, y: 20 }}\r\n                                        transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                        className=\"w-24 h-12 flex rounded border-2 shadow-sm bg-white overflow-hidden\"\r\n                                    >\r\n                                        {/* Data Part */}\r\n                                        <div className=\"flex-1 flex items-center justify-center font-bold text-gray-700 border-r border-gray-200\">\r\n                                            {node.value}\r\n                                        </div>\r\n                                        {/* Pointer Part */}\r\n                                        <div className=\"w-8 flex items-center justify-center bg-gray-50 text-gray-400 text-[10px]\">\r\n                                            ΓÇó\r\n                                        </div>\r\n                                    </motion.div>\r\n\r\n                                    {/* Arrow Connection */}\r\n                                    <motion.div\r\n                                        layout\r\n                                        className=\"mx-2 text-gray-400\"\r\n                                    >\r\n                                        <ArrowRight className=\"w-5 h-5\" />\r\n                                    </motion.div>\r\n                                </div>\r\n                            ))}\r\n                        </AnimatePresence>\r\n\r\n                        {/* NULL Terminator */}\r\n                        {currentState.nodes.length > 0 ? (\r\n                            <motion.div layout className=\"flex flex-col items-center\">\r\n                                <div className=\"text-sm font-bold text-gray-400\">NULL</div>\r\n                            </motion.div>\r\n                        ) : (\r\n                            <div className=\"w-full text-center text-gray-300 pointer-events-none\">Empty List</div>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\queue\\QueueVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\queue\\QueueVisualizer.tsx:30:13\n  28 |             }, 1000);\n  29 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 30 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  31 |         }\n  32 |         return () => {\n  33 |             if (interval) clearInterval(interval);","line":30,"column":13,"nodeType":null,"endLine":30,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Plus, Trash2, ArrowRight } from 'lucide-react';\r\n\r\ninterface QueueState {\r\n    items: number[];\r\n    message: string;\r\n    activeOperation: 'enqueue' | 'dequeue' | null;\r\n}\r\n\r\nexport const QueueVisualizer = () => {\r\n    const [history, setHistory] = useState<QueueState[]>([\r\n        { items: [], message: 'Queue is empty. Start by enqueuing an item.', activeOperation: null }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    // Playback Logic\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: QueueState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const handleEnqueue = () => {\r\n        if (!inputValue) return;\r\n        const num = parseInt(inputValue);\r\n        if (isNaN(num)) return;\r\n\r\n        if (currentState.items.length >= 7) {\r\n            alert(\"Queue full! Max 7 items for visualization.\");\r\n            return;\r\n        }\r\n\r\n        addToHistory({\r\n            items: [...currentState.items, num], // Append to end\r\n            message: `Enqueued ${num} to the rear.`,\r\n            activeOperation: 'enqueue'\r\n        });\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleDequeue = () => {\r\n        if (currentState.items.length === 0) {\r\n            addToHistory({\r\n                items: [],\r\n                message: 'Queue Underflow! Cannot dequeue from empty queue.',\r\n                activeOperation: null\r\n            });\r\n            return;\r\n        }\r\n\r\n        const [removed, ...rest] = currentState.items;\r\n        addToHistory({\r\n            items: rest,\r\n            message: `Dequeued ${removed} from the front.`,\r\n            activeOperation: 'dequeue'\r\n        });\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Queue Visualization\"\r\n            description=\"A Queue is a First-In-First-Out (FIFO) data structure.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-2xl\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex gap-2 w-full max-w-md bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n                    <div className=\"flex-1 flex gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Value\"\r\n                            className=\"w-20 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                            onKeyDown={(e) => e.key === 'Enter' && handleEnqueue()}\r\n                        />\r\n                        <button onClick={handleEnqueue} className=\"flex-1 flex items-center justify-center gap-1 bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 transition-colors\">\r\n                            <Plus className=\"w-3 h-3\" /> Enqueue\r\n                        </button>\r\n                    </div>\r\n\r\n                    <button onClick={handleDequeue} className=\"flex items-center gap-1 bg-red-100 text-red-700 px-3 py-1 rounded text-sm hover:bg-red-200 transition-colors\">\r\n                        <Trash2 className=\"w-3 h-3\" /> Dequeue\r\n                    </button>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                {/* Horizontal Layout for Queue */}\r\n                <div className=\"flex items-center justify-center w-full min-h-[120px] bg-gray-50/50 rounded-lg p-8 relative overflow-hidden\">\r\n\r\n                    {/* Labels */}\r\n                    {currentState.items.length > 0 && (\r\n                        <>\r\n                            <div className=\"absolute left-4 top-1/2 -translate-y-1/2 text-xs font-bold text-red-500 -rotate-90 origin-center\">FRONT</div>\r\n                            <div className=\"absolute right-4 top-1/2 -translate-y-1/2 text-xs font-bold text-blue-500 -rotate-90 origin-center\">REAR</div>\r\n                        </>\r\n                    )}\r\n\r\n                    <div className=\"flex items-center gap-4\">\r\n                        <AnimatePresence mode=\"popLayout\">\r\n                            {currentState.items.map((item, index) => (\r\n                                <motion.div\r\n                                    key={`${item}-${index}`} // Composite key to ensure uniqueness relative to position in this specific history flow isn't strictly necessary if items are unique, but better safe. Actually, index changes on dequeue, so we need a stable ID if possible, but for simple numbers, re-rendering is fine. Let's use value-index for generic visual.\r\n                                    layout\r\n                                    initial={{ opacity: 0, x: 100, scale: 0.8 }}\r\n                                    animate={{\r\n                                        opacity: 1,\r\n                                        x: 0,\r\n                                        scale: 1,\r\n                                        backgroundColor: '#ffffff',\r\n                                        borderColor: '#e5e7eb'\r\n                                    }}\r\n                                    exit={{ opacity: 0, scale: 0.8, x: -100, backgroundColor: '#fee2e2' }}\r\n                                    transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                    className=\"w-16 h-16 flex flex-col items-center justify-center rounded-lg border-2 shadow-sm text-xl font-bold text-gray-700 relative bg-white\"\r\n                                >\r\n                                    {item}\r\n                                    <span className=\"absolute -bottom-6 text-[10px] text-gray-400 font-normal\">\r\n                                        {index}\r\n                                    </span>\r\n                                    {index === 0 && (\r\n                                        <div className=\"absolute -top-3 w-2 h-2 rounded-full bg-red-500\" title=\"Head\" />\r\n                                    )}\r\n                                    {index === currentState.items.length - 1 && (\r\n                                        <div className=\"absolute -top-3 w-2 h-2 rounded-full bg-blue-500\" title=\"Tail\" />\r\n                                    )}\r\n                                </motion.div>\r\n                            ))}\r\n                        </AnimatePresence>\r\n                    </div>\r\n\r\n                    {currentState.items.length === 0 && (\r\n                        <div className=\"text-gray-300 text-sm pointer-events-none flex flex-col items-center gap-2\">\r\n                            <ArrowRight className=\"w-8 h-8 opacity-20\" />\r\n                            Empty Queue\r\n                        </div>\r\n                    )}\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\searching\\SearchingVisualizer.tsx","messages":[{"ruleId":"prefer-const","severity":2,"message":"'newArr' is never reassigned. Use 'const' instead.","line":28,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":28,"endColumn":19,"fix":{"range":[1151,1233],"text":"const newArr = Array.from({ length: 15 }, () => Math.floor(Math.random() * 99) + 1);"}},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\searching\\SearchingVisualizer.tsx:52:9\n  50 |\n  51 |     useEffect(() => {\n> 52 |         handleGenerateArray();\n     |         ^^^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  53 |     }, [algorithm]);\n  54 |\n  55 |     useEffect(() => {","line":52,"column":9,"nodeType":null,"endLine":52,"endColumn":28},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleGenerateArray'. Either include it or remove the dependency array.","line":53,"column":8,"nodeType":"ArrayExpression","endLine":53,"endColumn":19,"suggestions":[{"desc":"Update the dependencies array to be: [algorithm, handleGenerateArray]","fix":{"range":[1897,1908],"text":"[algorithm, handleGenerateArray]"}}]},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\searching\\SearchingVisualizer.tsx:62:13\n  60 |             }, 800);\n  61 |         } else if (currentStep >= history.length - 1) {\n> 62 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  63 |         }\n  64 |         return () => {\n  65 |             if (interval) clearInterval(interval);","line":62,"column":13,"nodeType":null,"endLine":62,"endColumn":25}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { RotateCcw, Search } from 'lucide-react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\n\r\ninterface SearchState {\r\n    array: number[];\r\n    activeIndices: number[]; // Indices currently being checked\r\n    foundIndex: number | null; // index where value was found\r\n    low: number | null; // For Binary Search\r\n    high: number | null; // For Binary Search\r\n    mid: number | null; // For Binary Search\r\n    message: string;\r\n}\r\n\r\nexport const SearchingVisualizer = () => {\r\n    const [history, setHistory] = useState<SearchState[]>([\r\n        { array: [], activeIndices: [], foundIndex: null, low: null, high: null, mid: null, message: 'Start by generating an array.' }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n    const [algorithm, setAlgorithm] = useState<'linear' | 'binary'>('linear');\r\n    const [targetValue, setTargetValue] = useState('');\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    const handleGenerateArray = () => {\r\n        let newArr = Array.from({ length: 15 }, () => Math.floor(Math.random() * 99) + 1);\r\n        if (algorithm === 'binary') {\r\n            newArr.sort((a, b) => a - b);\r\n        }\r\n        setHistory([{\r\n            array: newArr,\r\n            activeIndices: [],\r\n            foundIndex: null,\r\n            low: null,\r\n            high: null,\r\n            mid: null,\r\n            message: `Generated ${algorithm === 'binary' ? 'sorted' : 'random'} array.`\r\n        }]);\r\n        setCurrentStep(0);\r\n        setIsPlaying(false);\r\n    };\r\n\r\n    const addToHistory = (steps: SearchState[]) => {\r\n        setHistory(steps);\r\n        setCurrentStep(0);\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    useEffect(() => {\r\n        handleGenerateArray();\r\n    }, [algorithm]);\r\n\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 800);\r\n        } else if (currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const runLinearSearch = () => {\r\n        const target = parseInt(targetValue);\r\n        if (isNaN(target)) return;\r\n\r\n        const arr = currentState.array;\r\n        const steps: SearchState[] = [];\r\n        let found = false;\r\n\r\n        steps.push({\r\n            array: arr,\r\n            activeIndices: [],\r\n            foundIndex: null,\r\n            low: null, high: null, mid: null,\r\n            message: `Starting Linear Search for ${target}...`\r\n        });\r\n\r\n        for (let i = 0; i < arr.length; i++) {\r\n            steps.push({\r\n                array: arr,\r\n                activeIndices: [i],\r\n                foundIndex: null,\r\n                low: null, high: null, mid: null,\r\n                message: `Checking index ${i} (Value: ${arr[i]})...`\r\n            });\r\n\r\n            if (arr[i] === target) {\r\n                found = true;\r\n                steps.push({\r\n                    array: arr,\r\n                    activeIndices: [i],\r\n                    foundIndex: i,\r\n                    low: null, high: null, mid: null,\r\n                    message: `Found ${target} at index ${i}!`\r\n                });\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            steps.push({\r\n                array: arr,\r\n                activeIndices: [],\r\n                foundIndex: null,\r\n                low: null, high: null, mid: null,\r\n                message: `${target} not found in the array.`\r\n            });\r\n        }\r\n\r\n        addToHistory(steps);\r\n    };\r\n\r\n    const runBinarySearch = () => {\r\n        const target = parseInt(targetValue);\r\n        if (isNaN(target)) return;\r\n\r\n        const arr = currentState.array;\r\n        const steps: SearchState[] = [];\r\n        let low = 0;\r\n        let high = arr.length - 1;\r\n        let found = false;\r\n\r\n        steps.push({\r\n            array: arr,\r\n            activeIndices: [],\r\n            foundIndex: null,\r\n            low: low, high: high, mid: null,\r\n            message: `Starting Binary Search for ${target}...`\r\n        });\r\n\r\n        while (low <= high) {\r\n            const mid = Math.floor((low + high) / 2);\r\n\r\n            steps.push({\r\n                array: arr,\r\n                activeIndices: [mid],\r\n                foundIndex: null,\r\n                low: low, high: high, mid: mid,\r\n                message: `Checking Middle Index ${mid} (Value: ${arr[mid]})...`\r\n            });\r\n\r\n            if (arr[mid] === target) {\r\n                found = true;\r\n                steps.push({\r\n                    array: arr,\r\n                    activeIndices: [mid],\r\n                    foundIndex: mid,\r\n                    low: low, high: high, mid: mid,\r\n                    message: `Found ${target} at index ${mid}!`\r\n                });\r\n                break;\r\n            } else if (arr[mid] < target) {\r\n                steps.push({\r\n                    array: arr,\r\n                    activeIndices: [mid],\r\n                    foundIndex: null,\r\n                    low: low, high: high, mid: mid,\r\n                    message: `${arr[mid]} < ${target}. Ignoring left half.`\r\n                });\r\n                low = mid + 1;\r\n            } else {\r\n                steps.push({\r\n                    array: arr,\r\n                    activeIndices: [mid],\r\n                    foundIndex: null,\r\n                    low: low, high: high, mid: mid,\r\n                    message: `${arr[mid]} > ${target}. Ignoring right half.`\r\n                });\r\n                high = mid - 1;\r\n            }\r\n\r\n            // Show new range\r\n            if (low <= high) {\r\n                steps.push({\r\n                    array: arr,\r\n                    activeIndices: [],\r\n                    foundIndex: null,\r\n                    low: low, high: high, mid: null,\r\n                    message: `New Range: [${low}, ${high}]`\r\n                });\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            steps.push({\r\n                array: arr,\r\n                activeIndices: [],\r\n                foundIndex: null,\r\n                low: null, high: null, mid: null,\r\n                message: `${target} not found.`\r\n            });\r\n        }\r\n\r\n        addToHistory(steps);\r\n    };\r\n\r\n    const handleSearch = () => {\r\n        if (algorithm === 'linear') runLinearSearch();\r\n        else runBinarySearch();\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Searching Algorithms\"\r\n            description=\"Linear Search vs Binary Search.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={800}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-6 w-full max-w-4xl\">\r\n                <div className=\"flex items-center gap-2 bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n                    <button onClick={handleGenerateArray} className=\"flex items-center gap-1 bg-gray-100 text-gray-700 px-3 py-1 rounded text-sm hover:bg-gray-200 transition-colors\">\r\n                        <RotateCcw className=\"w-3 h-3\" /> Reset\r\n                    </button>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 mx-2\"></div>\r\n\r\n                    <select\r\n                        value={algorithm}\r\n                        onChange={(e) => setAlgorithm(e.target.value as 'linear' | 'binary')}\r\n                        className=\"px-2 py-1 border rounded text-sm\"\r\n                    >\r\n                        <option value=\"linear\">Linear Search</option>\r\n                        <option value=\"binary\">Binary Search (Sorted)</option>\r\n                    </select>\r\n\r\n                    <input\r\n                        type=\"number\"\r\n                        value={targetValue}\r\n                        onChange={(e) => setTargetValue(e.target.value)}\r\n                        placeholder=\"Target\"\r\n                        className=\"w-20 px-2 py-1 border rounded text-sm\"\r\n                    />\r\n\r\n                    <button onClick={handleSearch} className=\"flex items-center gap-1 bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 transition-colors\">\r\n                        <Search className=\"w-3 h-3\" /> Find\r\n                    </button>\r\n                </div>\r\n\r\n                <div className=\"flex items-center justify-center gap-2 flex-wrap w-full bg-gray-50 border rounded-lg p-8 min-h-[200px]\">\r\n                    <AnimatePresence>\r\n                        {currentState?.array.map((val, idx) => {\r\n                            const isActive = currentState.activeIndices.includes(idx);\r\n                            const isFound = currentState.foundIndex === idx;\r\n\r\n                            // Binary search specific styles\r\n                            let isRange = false;\r\n                            if (algorithm === 'binary' && currentState.low !== null && currentState.high !== null) {\r\n                                if (idx >= currentState.low && idx <= currentState.high) {\r\n                                    isRange = true;\r\n                                }\r\n                            }\r\n                            const isMid = currentState.mid === idx;\r\n\r\n                            return (\r\n                                <motion.div\r\n                                    key={idx}\r\n                                    layout\r\n                                    initial={{ scale: 0.8, opacity: 0 }}\r\n                                    animate={{\r\n                                        scale: isFound ? 1.1 : 1,\r\n                                        opacity: algorithm === 'binary' && !isRange && currentState.low !== null ? 0.3 : 1, // Dim items out of range\r\n                                        backgroundColor: isFound ? '#22c55e' : isMid ? '#eab308' : isActive ? '#3b82f6' : '#ffffff',\r\n                                        borderColor: isFound ? '#16a34a' : isMid ? '#ca8a04' : isActive ? '#2563eb' : '#cbd5e1',\r\n                                        color: (isActive || isFound || isMid) ? '#ffffff' : '#1e293b'\r\n                                    }}\r\n                                    className=\"w-10 h-10 flex items-center justify-center rounded border-2 font-bold shadow-sm relative\"\r\n                                >\r\n                                    {val}\r\n                                    <div className=\"absolute -bottom-5 text-[10px] text-gray-400\">\r\n                                        {idx}\r\n                                    </div>\r\n                                    {isMid && algorithm === 'binary' && <div className=\"absolute -top-6 text-[10px] text-yellow-600 font-bold\">MID</div>}\r\n                                    {idx === currentState.low && algorithm === 'binary' && <div className=\"absolute -top-6 text-[10px] text-blue-600 font-bold\">L</div>}\r\n                                    {idx === currentState.high && algorithm === 'binary' && <div className=\"absolute -top-6 text-[10px] text-blue-600 font-bold\">H</div>}\r\n                                </motion.div>\r\n                            );\r\n                        })}\r\n                    </AnimatePresence>\r\n                </div>\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\sorting\\SortingVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\sorting\\SortingVisualizer.tsx:45:9\n  43 |     useEffect(() => {\n  44 |         // Initial random array\n> 45 |         handleGenerateArray();\n     |         ^^^^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  46 |     }, []);\n  47 |\n  48 |     useEffect(() => {","line":45,"column":9,"nodeType":null,"endLine":45,"endColumn":28},{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\sorting\\SortingVisualizer.tsx:55:13\n  53 |             }, 100); // 100ms for faster sorting viz\n  54 |         } else if (currentStep >= history.length - 1) {\n> 55 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  56 |         }\n  57 |         return () => {\n  58 |             if (interval) clearInterval(interval);","line":55,"column":13,"nodeType":null,"endLine":55,"endColumn":25}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Play, RotateCcw } from 'lucide-react';\r\nimport { motion } from 'framer-motion';\r\n\r\ninterface SortingState {\r\n    array: number[];\r\n    comparedIndices: number[]; // Indices currently being compared\r\n    swappedIndices: number[]; // Indices just swapped\r\n    sortedIndices: number[]; // Indices that are fully sorted\r\n    message: string;\r\n}\r\n\r\nexport const SortingVisualizer = () => {\r\n    const [history, setHistory] = useState<SortingState[]>([\r\n        { array: [], comparedIndices: [], swappedIndices: [], sortedIndices: [], message: 'Start by generating a random array.' }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n    const [algorithm, setAlgorithm] = useState<'bubble' | 'selection'>('bubble');\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    const handleGenerateArray = () => {\r\n        const newArr = Array.from({ length: 15 }, () => Math.floor(Math.random() * 80) + 10);\r\n        setHistory([{\r\n            array: newArr,\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: [],\r\n            message: 'Generated new random array.'\r\n        }]);\r\n        setCurrentStep(0);\r\n        setIsPlaying(false);\r\n    };\r\n\r\n    const addToHistory = (steps: SortingState[]) => {\r\n        setHistory(steps);\r\n        setCurrentStep(0);\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    useEffect(() => {\r\n        // Initial random array\r\n        handleGenerateArray();\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 100); // 100ms for faster sorting viz\r\n        } else if (currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const runBubbleSort = () => {\r\n        const arr = [...currentState.array];\r\n        const steps: SortingState[] = [];\r\n\r\n        // Initial state\r\n        steps.push({\r\n            array: [...arr],\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: [],\r\n            message: 'Starting Bubble Sort...'\r\n        });\r\n\r\n        for (let i = 0; i < arr.length; i++) {\r\n            for (let j = 0; j < arr.length - i - 1; j++) {\r\n                // Compare\r\n                steps.push({\r\n                    array: [...arr],\r\n                    comparedIndices: [j, j + 1],\r\n                    swappedIndices: [],\r\n                    sortedIndices: [...(steps[steps.length - 1]?.sortedIndices || [])],\r\n                    message: `Comparing ${arr[j]} and ${arr[j + 1]}`\r\n                });\r\n\r\n                if (arr[j] > arr[j + 1]) {\r\n                    // Swap\r\n                    [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\r\n                    steps.push({\r\n                        array: [...arr],\r\n                        comparedIndices: [j, j + 1],\r\n                        swappedIndices: [j, j + 1],\r\n                        sortedIndices: [...(steps[steps.length - 1]?.sortedIndices || [])],\r\n                        message: `Swapped ${arr[j]} and ${arr[j + 1]}`\r\n                    });\r\n                }\r\n            }\r\n            // Mark last element as sorted\r\n            const sorted = [];\r\n            for (let k = 0; k <= i; k++) {\r\n                sorted.push(arr.length - 1 - k);\r\n            }\r\n            steps.push({\r\n                array: [...arr],\r\n                comparedIndices: [],\r\n                swappedIndices: [],\r\n                sortedIndices: sorted,\r\n                message: `${arr[arr.length - 1 - i]} is now in sorted position.`\r\n            });\r\n        }\r\n\r\n        steps.push({\r\n            array: [...arr],\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: arr.map((_, i) => i),\r\n            message: 'Bubble Sort Complete.'\r\n        });\r\n\r\n        addToHistory(steps);\r\n    };\r\n\r\n    const runSelectionSort = () => {\r\n        const arr = [...currentState.array];\r\n        const steps: SortingState[] = [];\r\n\r\n        steps.push({\r\n            array: [...arr],\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: [],\r\n            message: 'Starting Selection Sort...'\r\n        });\r\n\r\n        for (let i = 0; i < arr.length; i++) {\r\n            let minIdx = i;\r\n\r\n            for (let j = i + 1; j < arr.length; j++) {\r\n                steps.push({\r\n                    array: [...arr],\r\n                    comparedIndices: [minIdx, j],\r\n                    swappedIndices: [],\r\n                    sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                    message: `Checking if ${arr[j]} < current min ${arr[minIdx]}`\r\n                });\r\n\r\n                if (arr[j] < arr[minIdx]) {\r\n                    minIdx = j;\r\n                    steps.push({\r\n                        array: [...arr],\r\n                        comparedIndices: [minIdx],\r\n                        swappedIndices: [],\r\n                        sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                        message: `Found new minimum: ${arr[minIdx]}`\r\n                    });\r\n                }\r\n            }\r\n\r\n            if (minIdx !== i) {\r\n                [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\r\n                steps.push({\r\n                    array: [...arr],\r\n                    comparedIndices: [i, minIdx],\r\n                    swappedIndices: [i, minIdx],\r\n                    sortedIndices: Array.from({ length: i }, (_, k) => k),\r\n                    message: `Swapped minimum ${arr[i]} into position ${i}`\r\n                });\r\n            }\r\n\r\n            steps.push({\r\n                array: [...arr],\r\n                comparedIndices: [],\r\n                swappedIndices: [],\r\n                sortedIndices: Array.from({ length: i + 1 }, (_, k) => k),\r\n                message: `Index ${i} is now sorted.`\r\n            });\r\n        }\r\n\r\n        steps.push({\r\n            array: [...arr],\r\n            comparedIndices: [],\r\n            swappedIndices: [],\r\n            sortedIndices: arr.map((_, i) => i),\r\n            message: 'Selection Sort Complete.'\r\n        });\r\n\r\n        addToHistory(steps);\r\n    };\r\n\r\n    const handleSort = () => {\r\n        if (algorithm === 'bubble') runBubbleSort();\r\n        else runSelectionSort();\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Sorting Algorithms\"\r\n            description=\"Comparing Bubble Sort and Selection Sort.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={100}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-6 w-full max-w-4xl\">\r\n                <div className=\"flex items-center gap-2 bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n                    <button onClick={handleGenerateArray} className=\"flex items-center gap-1 bg-gray-100 text-gray-700 px-3 py-1 rounded text-sm hover:bg-gray-200 transition-colors\">\r\n                        <RotateCcw className=\"w-3 h-3\" /> Randomize\r\n                    </button>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 mx-2\"></div>\r\n\r\n                    <select\r\n                        value={algorithm}\r\n                        onChange={(e) => setAlgorithm(e.target.value as 'bubble' | 'selection')}\r\n                        className=\"px-2 py-1 border rounded text-sm\"\r\n                    >\r\n                        <option value=\"bubble\">Bubble Sort</option>\r\n                        <option value=\"selection\">Selection Sort</option>\r\n                    </select>\r\n\r\n                    <button onClick={handleSort} className=\"flex items-center gap-1 bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 transition-colors\">\r\n                        <Play className=\"w-3 h-3\" /> Sort\r\n                    </button>\r\n                </div>\r\n\r\n                <div className=\"flex items-end justify-center gap-2 h-[300px] w-full bg-gray-50 border rounded-lg p-8\">\r\n                    {currentState?.array.map((val, idx) => {\r\n                        const isCompared = currentState.comparedIndices.includes(idx);\r\n                        const isSwapped = currentState.swappedIndices.includes(idx);\r\n                        const isSorted = currentState.sortedIndices.includes(idx);\r\n\r\n                        return (\r\n                            <motion.div\r\n                                key={idx} // Index key is fine here as we aren't adding/removing, just swapping values\r\n                                layout\r\n                                transition={{ type: \"spring\", stiffness: 300, damping: 20 }}\r\n                                className=\"w-8 rounded-t-md relative group\"\r\n                                style={{\r\n                                    height: `${val * 3}px`,\r\n                                    backgroundColor: isSwapped ? '#ef4444' : isSorted ? '#22c55e' : isCompared ? '#eab308' : '#3b82f6'\r\n                                }}\r\n                            >\r\n                                <span className=\"absolute -top-6 left-1/2 -translate-x-1/2 text-xs text-gray-500 opacity-0 group-hover:opacity-100 transition-opacity\">\r\n                                    {val}\r\n                                </span>\r\n                            </motion.div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\stack\\StackVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\stack\\StackVisualizer.tsx:30:13\n  28 |             }, 1000); // Default speed, can be connected to props later\n  29 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 30 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  31 |         }\n  32 |         return () => {\n  33 |             if (interval) clearInterval(interval);","line":30,"column":13,"nodeType":null,"endLine":30,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Plus, Trash2, Eye } from 'lucide-react';\r\n\r\ninterface StackState {\r\n    items: number[];\r\n    message: string;\r\n    highlightIndex: number | null;\r\n}\r\n\r\nexport const StackVisualizer = () => {\r\n    const [history, setHistory] = useState<StackState[]>([\r\n        { items: [], message: 'Stack is empty. Start by pushing an item.', highlightIndex: null }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    // Playback Logic\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000); // Default speed, can be connected to props later\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: StackState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const handlePush = () => {\r\n        if (!inputValue) return;\r\n        const num = parseInt(inputValue);\r\n        if (isNaN(num)) return;\r\n\r\n        if (currentState.items.length >= 8) {\r\n            alert(\"Stack overflow! Max 8 items for visualization.\");\r\n            return;\r\n        }\r\n\r\n        addToHistory({\r\n            items: [num, ...currentState.items], // Stack acts as LIFO, pushing to front for visual stacking\r\n            message: `Pushed ${num} to the stack.`,\r\n            highlightIndex: 0\r\n        });\r\n        setInputValue('');\r\n    };\r\n\r\n    const handlePop = () => {\r\n        if (currentState.items.length === 0) {\r\n            addToHistory({\r\n                items: [],\r\n                message: 'Stack Underflow! Cannot pop from empty stack.',\r\n                highlightIndex: null\r\n            });\r\n            return;\r\n        }\r\n\r\n        const [popped, ...rest] = currentState.items;\r\n        addToHistory({\r\n            items: rest,\r\n            message: `Popped ${popped} from the stack.`,\r\n            highlightIndex: null\r\n        });\r\n    };\r\n\r\n    const handlePeek = () => {\r\n        if (currentState.items.length === 0) {\r\n            addToHistory({\r\n                ...currentState,\r\n                message: 'Stack is empty. Nothing to peek.',\r\n                highlightIndex: null\r\n            });\r\n            return;\r\n        }\r\n        addToHistory({\r\n            ...currentState,\r\n            message: `Top element is ${currentState.items[0]}.`,\r\n            highlightIndex: 0\r\n        });\r\n    };\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Stack Visualization\"\r\n            description=\"A Stack is a Last-In-First-Out (LIFO) data structure.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-md\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex gap-2 w-full bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n                    <div className=\"flex-1 flex gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Value\"\r\n                            className=\"w-20 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                            onKeyDown={(e) => e.key === 'Enter' && handlePush()}\r\n                        />\r\n                        <button onClick={handlePush} className=\"flex-1 flex items-center justify-center gap-1 bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 transition-colors\">\r\n                            <Plus className=\"w-3 h-3\" /> Push\r\n                        </button>\r\n                    </div>\r\n\r\n                    <button onClick={handlePop} className=\"flex items-center gap-1 bg-red-100 text-red-700 px-3 py-1 rounded text-sm hover:bg-red-200 transition-colors\">\r\n                        <Trash2 className=\"w-3 h-3\" /> Pop\r\n                    </button>\r\n\r\n                    <button onClick={handlePeek} className=\"flex items-center gap-1 bg-purple-100 text-purple-700 px-3 py-1 rounded text-sm hover:bg-purple-200 transition-colors\">\r\n                        <Eye className=\"w-3 h-3\" /> Peek\r\n                    </button>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                <div className=\"flex flex-col-reverse items-center justify-end w-40 min-h-[300px] border-b-4 border-l-4 border-r-4 border-gray-400 rounded-b-lg p-2 bg-gray-50/50 relative\">\r\n                    <AnimatePresence>\r\n                        {currentState.items.map((item, index) => (\r\n                            <motion.div\r\n                                key={`${item}-${currentState.items.length - index}`} // Unique key for LIFO order\r\n                                layout\r\n                                initial={{ opacity: 0, y: -50, scale: 0.8 }}\r\n                                animate={{\r\n                                    opacity: 1,\r\n                                    y: 0,\r\n                                    scale: 1,\r\n                                    backgroundColor: index === currentState.highlightIndex ? '#dbeafe' : '#ffffff', // blue-100 vs white\r\n                                    borderColor: index === currentState.highlightIndex ? '#2563eb' : '#e5e7eb' // blue-600 vs gray-200\r\n                                }}\r\n                                exit={{ opacity: 0, scale: 0.8, x: 50 }}\r\n                                transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                className=\"w-full h-12 flex items-center justify-center rounded-md border-2 shadow-sm text-lg font-bold text-gray-700 mb-2 last:mb-0 relative\"\r\n                            >\r\n                                {item}\r\n                                <span className=\"absolute -left-12 text-xs text-gray-400 font-normal\">\r\n                                    Index {currentState.items.length - 1 - index}\r\n                                </span>\r\n                            </motion.div>\r\n                        ))}\r\n                    </AnimatePresence>\r\n\r\n                    {currentState.items.length === 0 && (\r\n                        <div className=\"absolute inset-0 flex items-center justify-center text-gray-300 text-sm pointer-events-none\">\r\n                            Empty Stack\r\n                        </div>\r\n                    )}\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\tree\\BinaryTreeVisualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\dataStructures\\tree\\BinaryTreeVisualizer.tsx:90:13\n  88 |             }, 1000);\n  89 |         } else if (isPlaying && currentStep >= history.length - 1) {\n> 90 |             setIsPlaying(false);\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  91 |         }\n  92 |         return () => {\n  93 |             if (interval) clearInterval(interval);","line":90,"column":13,"nodeType":null,"endLine":90,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { BaseVisualizer } from '../BaseVisualizer';\r\nimport { Plus, Play, Search, Trash2 } from 'lucide-react';\r\n\r\ninterface TreeNode {\r\n    id: string;\r\n    value: number;\r\n    left: TreeNode | null;\r\n    right: TreeNode | null;\r\n    x?: number; // Calculated for rendering\r\n    y?: number;\r\n}\r\n\r\ninterface TreeState {\r\n    root: TreeNode | null;\r\n    message: string;\r\n    activeIds: string[];\r\n}\r\n\r\n// Helper to layout tree\r\nconst layoutTree = (node: TreeNode | null, x: number, y: number, level: number): TreeNode | null => {\r\n    if (!node) return null;\r\n\r\n    // Horizontal spacing decreases as level increases to avoid overlap\r\n    // Level 0: 200px gap (approx) relative to parent? No, width/2^level\r\n    const offset = 200 / Math.pow(1.5, level);\r\n\r\n    const newNode = { ...node, x, y };\r\n    newNode.left = layoutTree(node.left, x - offset, y + 60, level + 1);\r\n    newNode.right = layoutTree(node.right, x + offset, y + 60, level + 1);\r\n    return newNode;\r\n};\r\n\r\ninterface TreeEdge {\r\n    id: string;\r\n    x1: number;\r\n    y1: number;\r\n    x2: number;\r\n    y2: number;\r\n}\r\n\r\n// Flatten tree for rendering\r\nconst flattenTree = (node: TreeNode | null, nodes: TreeNode[] = [], edges: TreeEdge[] = []): { nodes: TreeNode[], edges: TreeEdge[] } => {\r\n    if (!node) return { nodes, edges };\r\n\r\n    nodes.push(node);\r\n\r\n    if (node.left) {\r\n        edges.push({ id: `${node.id}-${node.left.id}`, x1: node.x!, y1: node.y!, x2: node.left.x!, y2: node.left.y! });\r\n        flattenTree(node.left, nodes, edges);\r\n    }\r\n    if (node.right) {\r\n        edges.push({ id: `${node.id}-${node.right.id}`, x1: node.x!, y1: node.y!, x2: node.right.x!, y2: node.right.y! });\r\n        flattenTree(node.right, nodes, edges);\r\n    }\r\n    return { nodes, edges };\r\n};\r\n\r\nconst cloneTree = (node: TreeNode | null): TreeNode | null => {\r\n    if (!node) return null;\r\n    return {\r\n        ...node,\r\n        left: cloneTree(node.left),\r\n        right: cloneTree(node.right)\r\n    };\r\n};\r\n\r\nexport const BinaryTreeVisualizer = () => {\r\n    const [history, setHistory] = useState<TreeState[]>([\r\n        { root: null, message: 'Tree is empty. Start by inserting a value.', activeIds: [] }\r\n    ]);\r\n    const [currentStep, setCurrentStep] = useState(0);\r\n    const [inputValue, setInputValue] = useState('');\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    const currentState = history[currentStep];\r\n\r\n    // Calculate layout for current state\r\n    const rootWithLayout = layoutTree(currentState.root, 400, 50, 0); // 400 is center of 800px canvas\r\n    const { nodes: renderNodes, edges: renderEdges } = flattenTree(rootWithLayout);\r\n\r\n    useEffect(() => {\r\n        let interval: ReturnType<typeof setInterval> | undefined;\r\n        if (isPlaying && currentStep < history.length - 1) {\r\n            interval = setInterval(() => {\r\n                setCurrentStep(prev => prev + 1);\r\n            }, 1000);\r\n        } else if (isPlaying && currentStep >= history.length - 1) {\r\n            setIsPlaying(false);\r\n        }\r\n        return () => {\r\n            if (interval) clearInterval(interval);\r\n        };\r\n    }, [isPlaying, currentStep, history.length]);\r\n\r\n    const addToHistory = (newState: TreeState) => {\r\n        const newHistory = [...history.slice(0, currentStep + 1), newState];\r\n        setHistory(newHistory);\r\n        setCurrentStep(newHistory.length - 1);\r\n    };\r\n\r\n    const handleInsert = () => {\r\n        const val = parseInt(inputValue);\r\n        if (isNaN(val)) return;\r\n\r\n        if (currentState.activeIds.length > 0) {\r\n            // Clear previous selection\r\n        }\r\n\r\n        const newRoot = cloneTree(currentState.root);\r\n\r\n        // BST Insert Logic\r\n        const maxDepth = 4;\r\n\r\n        if (!newRoot) {\r\n            addToHistory({\r\n                root: { id: `node-${Date.now()}`, value: val, left: null, right: null },\r\n                message: `Inserted root ${val}.`,\r\n                activeIds: []\r\n            });\r\n            setInputValue('');\r\n            return;\r\n        }\r\n\r\n        const insertNode = (node: TreeNode, value: number, depth: number): boolean => {\r\n            if (depth >= maxDepth) {\r\n                alert(\"Max tree depth reached for visualization.\");\r\n                return false;\r\n            }\r\n            if (value < node.value) {\r\n                if (!node.left) {\r\n                    node.left = { id: `node-${Date.now()}`, value, left: null, right: null };\r\n                    return true;\r\n                } else {\r\n                    return insertNode(node.left, value, depth + 1);\r\n                }\r\n            } else {\r\n                if (!node.right) {\r\n                    node.right = { id: `node-${Date.now()}`, value, left: null, right: null };\r\n                    return true;\r\n                } else {\r\n                    return insertNode(node.right, value, depth + 1);\r\n                }\r\n            }\r\n        };\r\n\r\n        if (insertNode(newRoot, val, 0)) {\r\n            addToHistory({\r\n                root: newRoot,\r\n                message: `Inserted ${val} into BST.`,\r\n                activeIds: []\r\n            });\r\n        }\r\n\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleTraversal = (type: 'inorder' | 'preorder' | 'postorder') => {\r\n        if (!currentState.root) return;\r\n\r\n        const traversalSteps: string[] = [];\r\n        const traversalNodes: TreeNode[] = [];\r\n\r\n        const traverse = (node: TreeNode | null) => {\r\n            if (!node) return;\r\n\r\n            if (type === 'preorder') {\r\n                traversalSteps.push(node.id);\r\n                traversalNodes.push(node);\r\n            }\r\n\r\n            traverse(node.left);\r\n\r\n            if (type === 'inorder') {\r\n                traversalSteps.push(node.id);\r\n                traversalNodes.push(node);\r\n            }\r\n\r\n            traverse(node.right);\r\n\r\n            if (type === 'postorder') {\r\n                traversalSteps.push(node.id);\r\n                traversalNodes.push(node);\r\n            }\r\n        };\r\n\r\n        traverse(currentState.root);\r\n\r\n        // Generate history from steps\r\n        const baseHistory = history.slice(0, currentStep + 1);\r\n        const newHistoryItems: TreeState[] = [];\r\n\r\n        traversalSteps.forEach((id, index) => {\r\n            const nodeVal = traversalNodes[index].value;\r\n            newHistoryItems.push({\r\n                root: currentState.root, // Structure doesn't change\r\n                message: `${type.charAt(0).toUpperCase() + type.slice(1)}: Visiting ${nodeVal}`,\r\n                activeIds: [id]\r\n            });\r\n        });\r\n\r\n        newHistoryItems.push({\r\n            root: currentState.root,\r\n            message: 'Traversal Complete.',\r\n            activeIds: []\r\n        });\r\n\r\n        setHistory([...baseHistory, ...newHistoryItems]);\r\n        setCurrentStep(currentStep + 1);\r\n        setIsPlaying(true);\r\n    };\r\n\r\n    const handleSearch = () => {\r\n        const val = parseInt(inputValue);\r\n        if (isNaN(val)) return;\r\n        if (!currentState.root) return;\r\n\r\n        let curr: TreeNode | null = currentState.root;\r\n        const searchSteps: TreeState[] = [];\r\n        let found = false;\r\n\r\n        while (curr) {\r\n            searchSteps.push({\r\n                root: currentState.root,\r\n                message: `Searching for ${val}... Visiting ${curr.value}`,\r\n                activeIds: [curr.id]\r\n            });\r\n\r\n            if (val === curr.value) {\r\n                found = true;\r\n                searchSteps.push({\r\n                    root: currentState.root,\r\n                    message: `Found ${val}!`,\r\n                    activeIds: [curr.id]\r\n                });\r\n                break;\r\n            } else if (val < curr.value) {\r\n                curr = curr.left;\r\n            } else {\r\n                curr = curr.right;\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            searchSteps.push({\r\n                root: currentState.root,\r\n                message: `${val} not found.`,\r\n                activeIds: []\r\n            });\r\n        }\r\n\r\n        const baseHistory = history.slice(0, currentStep + 1);\r\n        setHistory([...baseHistory, ...searchSteps]);\r\n        setCurrentStep(baseHistory.length);\r\n        setIsPlaying(true);\r\n        setInputValue('');\r\n    };\r\n\r\n    const handleDelete = () => {\r\n        const val = parseInt(inputValue);\r\n        if (isNaN(val)) return;\r\n\r\n        const newRoot = cloneTree(currentState.root);\r\n        let deleted = false;\r\n\r\n        const deleteNode = (node: TreeNode | null, v: number): TreeNode | null => {\r\n            if (!node) return null;\r\n            if (v < node.value) {\r\n                node.left = deleteNode(node.left, v);\r\n                return node;\r\n            } else if (v > node.value) {\r\n                node.right = deleteNode(node.right, v);\r\n                return node;\r\n            } else {\r\n                deleted = true;\r\n                // Node with only one child or no child\r\n                if (!node.left) return node.right;\r\n                if (!node.right) return node.left;\r\n\r\n                // Node with two children: Get inorder successor (smallest in the right subtree)\r\n                let temp = node.right;\r\n                while (temp.left) {\r\n                    temp = temp.left;\r\n                }\r\n                node.value = temp.value;\r\n                node.right = deleteNode(node.right, temp.value);\r\n                return node;\r\n            }\r\n        };\r\n\r\n        const finalRoot = deleteNode(newRoot, val);\r\n\r\n        if (deleted) {\r\n            addToHistory({\r\n                root: finalRoot,\r\n                message: `Deleted ${val}.`,\r\n                activeIds: []\r\n            });\r\n        } else {\r\n            addToHistory({\r\n                root: currentState.root,\r\n                message: `Cannot delete ${val}: Not found.`,\r\n                activeIds: []\r\n            });\r\n        }\r\n        setInputValue('');\r\n    };\r\n\r\n\r\n    return (\r\n        <BaseVisualizer\r\n            title=\"Binary Search Tree\"\r\n            description=\"Hierarchical data structure. Left child < Parent < Right child.\"\r\n            currentStep={currentStep}\r\n            totalSteps={history.length}\r\n            isPlaying={isPlaying}\r\n            onPlayPause={() => setIsPlaying(!isPlaying)}\r\n            onNext={() => setCurrentStep(Math.min(currentStep + 1, history.length - 1))}\r\n            onPrev={() => setCurrentStep(Math.max(currentStep - 1, 0))}\r\n            onReset={() => setCurrentStep(0)}\r\n            speed={1000}\r\n            onSpeedChange={() => { }}\r\n        >\r\n            <div className=\"flex flex-col items-center gap-8 w-full max-w-4xl\">\r\n\r\n                {/* Operations Panel */}\r\n                <div className=\"flex flex-wrap items-center justify-center gap-4 w-full bg-white p-4 rounded-lg shadow-sm border border-gray-200\">\r\n\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <input\r\n                            type=\"number\"\r\n                            value={inputValue}\r\n                            onChange={(e) => setInputValue(e.target.value)}\r\n                            placeholder=\"Val\"\r\n                            className=\"w-20 px-2 py-1 border rounded text-sm focus:outline-blue-500\"\r\n                            onKeyDown={(e) => {\r\n                                if (e.key === 'Enter') handleInsert();\r\n                            }}\r\n                        />\r\n                        <button onClick={handleInsert} className=\"flex items-center gap-1 bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 transition-colors\">\r\n                            <Plus className=\"w-3 h-3\" /> Insert\r\n                        </button>\r\n                        <button onClick={handleSearch} className=\"flex items-center gap-1 bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700 transition-colors\">\r\n                            <Search className=\"w-3 h-3\" /> Search\r\n                        </button>\r\n                        <button onClick={handleDelete} className=\"flex items-center gap-1 bg-red-600 text-white px-3 py-1 rounded text-sm hover:bg-red-700 transition-colors\">\r\n                            <Trash2 className=\"w-3 h-3\" /> Delete\r\n                        </button>\r\n                    </div>\r\n\r\n                    <div className=\"w-px h-8 bg-gray-200 hidden md:block\"></div>\r\n\r\n                    <div className=\"flex gap-2\">\r\n                        <button onClick={() => handleTraversal('inorder')} className=\"flex items-center gap-1 bg-purple-100 text-purple-700 px-2 py-1 rounded text-xs hover:bg-purple-200 transition-colors\">\r\n                            <Play className=\"w-3 h-3\" /> Inorder\r\n                        </button>\r\n                        <button onClick={() => handleTraversal('preorder')} className=\"flex items-center gap-1 bg-purple-100 text-purple-700 px-2 py-1 rounded text-xs hover:bg-purple-200 transition-colors\">\r\n                            <Play className=\"w-3 h-3\" /> Pre\r\n                        </button>\r\n                        <button onClick={() => handleTraversal('postorder')} className=\"flex items-center gap-1 bg-purple-100 text-purple-700 px-2 py-1 rounded text-xs hover:bg-purple-200 transition-colors\">\r\n                            <Play className=\"w-3 h-3\" /> Post\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n\r\n                {/* Message Area */}\r\n                <div className=\"min-h-[24px] text-center font-medium text-gray-600\">\r\n                    {currentState.message}\r\n                </div>\r\n\r\n                {/* Visualization Canvas */}\r\n                <div className=\"w-full h-[400px] bg-gray-50/50 rounded-lg relative overflow-hidden flex items-center justify-center\">\r\n                    <div className=\"relative w-full h-full max-w-[800px]\">\r\n\r\n                        {/* SVG Layer for Edges */}\r\n                        <svg className=\"absolute inset-0 w-full h-full pointer-events-none z-0\">\r\n                            {renderEdges.map(edge => (\r\n                                <motion.line\r\n                                    key={edge.id}\r\n                                    initial={{ pathLength: 0, opacity: 0 }}\r\n                                    animate={{ pathLength: 1, opacity: 1 }}\r\n                                    x1={edge.x1}\r\n                                    y1={edge.y1}\r\n                                    x2={edge.x2}\r\n                                    y2={edge.y2}\r\n                                    stroke=\"#cbd5e1\"\r\n                                    strokeWidth=\"2\"\r\n                                />\r\n                            ))}\r\n                        </svg>\r\n\r\n                        {/* Nodes Layer */}\r\n                        <AnimatePresence>\r\n                            {renderNodes.map((node) => (\r\n                                <motion.div\r\n                                    key={node.id}\r\n                                    layout\r\n                                    initial={{ scale: 0, opacity: 0 }}\r\n                                    animate={{\r\n\r\n                                        opacity: 1,\r\n                                        left: node.x,\r\n                                        top: node.y,\r\n                                        x: '-50%', // Center the node on the coordinate\r\n                                        y: '-50%',\r\n                                        backgroundColor: currentState.activeIds.includes(node.id) ? '#dbeafe' : '#ffffff',\r\n                                        borderColor: currentState.activeIds.includes(node.id) ? '#2563eb' : '#e5e7eb',\r\n                                        scale: currentState.activeIds.includes(node.id) ? 1.2 : 1\r\n                                    }}\r\n                                    transition={{ type: \"spring\", stiffness: 300, damping: 25 }}\r\n                                    className=\"absolute w-10 h-10 flex items-center justify-center rounded-full border-2 bg-white shadow-sm font-bold text-gray-700 z-10\"\r\n                                >\r\n                                    {node.value}\r\n                                </motion.div>\r\n                            ))}\r\n                        </AnimatePresence>\r\n\r\n                        {renderNodes.length === 0 && (\r\n                            <div className=\"absolute inset-0 flex items-center justify-center text-gray-300\">\r\n                                Empty Tree\r\n                            </div>\r\n                        )}\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        </BaseVisualizer>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\editor\\MonacoEditor.tsx","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":20,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":20,"endColumn":22,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[480,493],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Editor, { type OnMount } from '@monaco-editor/react';\r\nimport { useRef } from 'react';\r\n\r\ninterface MonacoEditorProps {\r\n    code: string;\r\n    language: string;\r\n    onChange?: (value: string | undefined) => void;\r\n    readOnly?: boolean;\r\n}\r\n\r\nexport const MonacoEditor = ({\r\n    code,\r\n    language,\r\n    onChange,\r\n    readOnly = false\r\n}: MonacoEditorProps) => {\r\n    const editorRef = useRef(null);\r\n\r\n    const handleEditorDidMount: OnMount = (editor) => {\r\n        // @ts-ignore\r\n        editorRef.current = editor;\r\n    };\r\n\r\n    return (\r\n        <div className=\"h-full w-full overflow-hidden rounded-md border border-gray-700 shadow-inner\">\r\n            <Editor\r\n                height=\"100%\"\r\n                defaultLanguage=\"python\"\r\n                language={language}\r\n                value={code}\r\n                onChange={onChange}\r\n                onMount={handleEditorDidMount}\r\n                theme=\"vs-dark\"\r\n                options={{\r\n                    readOnly: readOnly,\r\n                    minimap: { enabled: false },\r\n                    scrollBeyondLastLine: false,\r\n                    fontSize: 14,\r\n                    wordWrap: 'on',\r\n                    automaticLayout: true,\r\n                    padding: { top: 16 }\r\n                }}\r\n                loading={\r\n                    <div className=\"flex items-center justify-center h-full text-gray-400\">\r\n                        Loading Editor...\r\n                    </div>\r\n                }\r\n            />\r\n        </div>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\features\\ChatPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\features\\CodeEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\features\\Visualizer.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nD:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\features\\Visualizer.tsx:13:13\n  11 |     useEffect(() => {\n  12 |         if (!code) {\n> 13 |             setIframeSrc('');\n     |             ^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  14 |             return;\n  15 |         }\n  16 |","line":13,"column":13,"nodeType":null,"endLine":13,"endColumn":25}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\r\n\r\ninterface VisualizerProps {\r\n    code: string | null;\r\n    title?: string;\r\n}\r\n\r\nconst Visualizer: React.FC<VisualizerProps> = ({ code, title }) => {\r\n    const [iframeSrc, setIframeSrc] = useState<string>('');\r\n\r\n    useEffect(() => {\r\n        if (!code) {\r\n            setIframeSrc('');\r\n            return;\r\n        }\r\n\r\n        // Create a separate document structure if code doesn't have it?\r\n        // The RAG docs we seeded are just the body relevant parts inside markdown blocks.\r\n        // We probably need to strip the markdown blocks if they exist, or the backend does it.\r\n        // The current backend endpoint returns 'visualizer_code' which is the raw content of the doc.\r\n        // The doc content in seed_visualizers.py is:\r\n        // \"Here is ... \\n ```html ... ``` \\n ```css ... ```\"\r\n        // The logic in Chat endpoint `chat.py` extracts code blocks. \r\n        // Our new RAG endpoint returns the raw doc. \r\n        // We should parse it on the frontend OR backend.\r\n        // The user request said: \"It parses the raw string to separate HTML, CSS, and JS [...]\"\r\n\r\n        // Let's implement a simple parser here to construct a full HTML file.\r\n        const constructHtml = (rawCode: string) => {\r\n            // 1. naive check if it's already a full HTML\r\n            if (rawCode.trim().startsWith('<!DOCTYPE html>') || rawCode.trim().startsWith('<html')) {\r\n                return rawCode;\r\n            }\r\n\r\n            // 2. Extract blocks\r\n            const htmlMatch = rawCode.match(/```html\\n([\\s\\S]*?)```/i);\r\n            const cssMatch = rawCode.match(/```css\\n([\\s\\S]*?)```/i);\r\n            const jsMatch = rawCode.match(/```(?:javascript|js)\\n([\\s\\S]*?)```/i);\r\n\r\n            const html = htmlMatch ? htmlMatch[1] : '';\r\n            const css = cssMatch ? cssMatch[1] : '';\r\n            const js = jsMatch ? jsMatch[1] : '';\r\n\r\n            if (!html && !css && !js) {\r\n                // Determine if rawCode is just HTML\r\n                return rawCode;\r\n            }\r\n\r\n            return `\r\n                <!DOCTYPE html>\r\n                <html>\r\n                <head>\r\n                    <style>\r\n                        body { font-family: sans-serif; padding: 10px; }\r\n                        ${css}\r\n                    </style>\r\n                </head>\r\n                <body>\r\n                    ${html}\r\n                    <script>\r\n                        try {\r\n                            ${js}\r\n                        } catch(e) {\r\n                            console.error(\"Visualization Error:\", e);\r\n                            document.body.innerHTML += '<div style=\"color:red\">Runtime Error: ' + e.message + '</div>';\r\n                        }\r\n                    </script>\r\n                </body>\r\n                </html>\r\n            `;\r\n        };\r\n\r\n        const finalHtml = constructHtml(code);\r\n        const blob = new Blob([finalHtml], { type: 'text/html' });\r\n        const url = URL.createObjectURL(blob);\r\n        setIframeSrc(url);\r\n\r\n        return () => {\r\n            URL.revokeObjectURL(url);\r\n        };\r\n    }, [code]);\r\n\r\n    if (!code) {\r\n        return (\r\n            <div className=\"flex items-center justify-center h-full bg-gray-50 border-2 border-dashed border-gray-300 rounded-lg p-10 text-gray-400\">\r\n                <p>Select a data structure to view its visualization.</p>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <div className=\"w-full h-full flex flex-col bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden\">\r\n            {title && (\r\n                <div className=\"bg-gray-100 px-4 py-2 border-b border-gray-200 font-medium text-gray-700 flex justify-between items-center\">\r\n                    <span>{title}</span>\r\n                </div>\r\n            )}\r\n            <div className=\"flex-1 relative bg-white\">\r\n                <iframe\r\n                    src={iframeSrc}\r\n                    className=\"w-full h-full border-0\"\r\n                    sandbox=\"allow-scripts allow-modals allow-popups allow-forms\"\r\n                    title=\"Data Structure Visualization\"\r\n                />\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Visualizer;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\features\\VisualizerPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\features\\chat\\ChatInterface.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\features\\chat\\ChatMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\preview\\LivePreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\components\\ui\\Tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\pages\\CodeViz.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\pages\\Home.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\services\\VisualizationController.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":152,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":152,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createContext, useContext, useState, type ReactNode } from 'react';\r\n\r\ntype Tab = 'chat' | 'editor' | 'visualizer';\r\n\r\ninterface CodeBlock {\r\n    language: string;\r\n    code: string;\r\n}\r\n\r\ninterface BackendResponse {\r\n    code_blocks?: CodeBlock[];\r\n    code?: string;\r\n    visualization_type?: string;\r\n    implementation_code?: {\r\n        code: string;\r\n    };\r\n}\r\n\r\ninterface VisualizationContextType {\r\n    activeTab: Tab;\r\n    setActiveTab: (tab: Tab) => void;\r\n    visualizationType: string | null;\r\n    setVisualizationType: (type: string | null) => void;\r\n    code: string;\r\n    setCode: (code: string) => void;\r\n    processBackendResponse: (data: BackendResponse) => void;\r\n    error: string | null;\r\n    setError: (error: string | null) => void;\r\n    output: string | null;\r\n    setOutput: (output: string | null) => void;\r\n    implementationCode: string | null;\r\n    setImplementationCode: (code: string | null) => void;\r\n}\r\n\r\nconst VisualizationContext = createContext<VisualizationContextType | undefined>(undefined);\r\n\r\nexport const VisualizationProvider = ({ children }: { children: ReactNode }) => {\r\n    const [activeTab, setActiveTab] = useState<Tab>('chat');\r\n    const [visualizationType, setVisualizationType] = useState<string | null>(null);\r\n    const [code, setCode] = useState<string>('// Start coding or ask the AI to generate code...');\r\n    const [error, setError] = useState<string | null>(null);\r\n    const [output, setOutput] = useState<string | null>(null);\r\n    const [implementationCode, setImplementationCode] = useState<string | null>(null);\r\n\r\n    const processBackendResponse = (data: BackendResponse) => {\r\n        try {\r\n            console.log(\"DEBUG: processBackendResponse received:\", JSON.stringify(data, null, 2));\r\n\r\n            // 1. Handle Code\r\n\r\n            // 1. Handle Code\r\n            if (data.code_blocks && data.code_blocks.length > 0) {\r\n                // Check if we have HTML/CSS/JS blocks\r\n                let html = '';\r\n                let css = '';\r\n                let js = '';\r\n                let hasWebCode = false;\r\n\r\n                data.code_blocks.forEach((block: CodeBlock) => {\r\n                    const lang = block.language.toLowerCase();\r\n                    if (lang === 'html') { html = block.code; hasWebCode = true; }\r\n                    else if (lang === 'css') { css = block.code; hasWebCode = true; }\r\n                    else if (lang === 'javascript' || lang === 'js') { js = block.code; hasWebCode = true; }\r\n                });\r\n\r\n\r\n                if (hasWebCode) {\r\n                    // Assemble into a single HTML string for LivePreview\r\n                    const assembledCode = `\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<style>\r\n${css}\r\n</style>\r\n</head>\r\n<body>\r\n${html}\r\n<script>\r\n${js}\r\n</script>\r\n</body>\r\n</html>`;\r\n                    setCode(assembledCode.trim());\r\n\r\n                    // Force switch to visualizer if logic is missing from backend response (double safety)\r\n                    if (!data.visualization_type || data.visualization_type === 'none') {\r\n                        setVisualizationType('html');\r\n                        setActiveTab('visualizer');\r\n                    }\r\n                } else {\r\n                    // Fallback to simple join for other languages (e.g. Python)\r\n                    const combinedCode = data.code_blocks.map((block: CodeBlock) =>\r\n                        `// [${block.language.toUpperCase()}]\\n${block.code}`\r\n                    ).join('\\n\\n');\r\n                    setCode(combinedCode);\r\n                }\r\n            }\r\n            else if (data.code) {\r\n                setCode(data.code);\r\n            }\r\n\r\n\r\n\r\n            // 2. Handle Visualization\r\n            if (data.visualization_type && data.visualization_type !== 'none') {\r\n                setVisualizationType(data.visualization_type);\r\n                setActiveTab('visualizer');\r\n            } else if (data.code && (!data.visualization_type || data.visualization_type === 'none')) {\r\n                // If only code is returned, maybe switch to editor?\r\n                // User might prefer to stay in chat, so let's check\r\n                // For now, let's keep user in current tab unless explicit visualizer\r\n            }\r\n\r\n            // 3. Handle Implementation Code (New Feature)\r\n            if (data.implementation_code && data.implementation_code.code) {\r\n                setImplementationCode(data.implementation_code.code);\r\n            } else {\r\n                setImplementationCode(null);\r\n            }\r\n\r\n            // 4. Clear errors if successful\r\n            setError(null);\r\n\r\n        } catch (err) {\r\n            console.error(\"Error processing backend response:\", err);\r\n            setError(\"Failed to process the response. Please try again.\");\r\n        }\r\n    };\r\n\r\n    return (\r\n        <VisualizationContext.Provider value={{\r\n            activeTab,\r\n            setActiveTab,\r\n            visualizationType,\r\n            setVisualizationType,\r\n            code,\r\n            setCode,\r\n            processBackendResponse,\r\n            error,\r\n            setError,\r\n            output,\r\n            setOutput,\r\n            implementationCode,\r\n            setImplementationCode\r\n        }}>\r\n            {children}\r\n        </VisualizationContext.Provider>\r\n    );\r\n};\r\n\r\nexport const useVisualization = () => {\r\n    const context = useContext(VisualizationContext);\r\n    if (context === undefined) {\r\n        throw new Error('useVisualization must be used within a VisualizationProvider');\r\n    }\r\n    return context;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\services\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\src\\types\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[501,504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[501,504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type Role = 'user' | 'assistant';\r\n\r\nexport interface Message {\r\n    id: string;\r\n    role: Role;\r\n    content: string;\r\n    timestamp: number;\r\n}\r\n\r\nexport type VisualizationType = 'none' | 'html' | 'data_structure' | 'algorithm';\r\n\r\nexport interface CodeBlock {\r\n    language: string;\r\n    code: string;\r\n    title?: string;\r\n}\r\n\r\nexport interface ChatResponse {\r\n    text_response: string;\r\n    visualization_type: VisualizationType;\r\n    code_blocks: CodeBlock[];\r\n    visualization_data?: any;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\FINAL-YEAR-PROJECT\\CODEVIZ-2.0\\frontend\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
