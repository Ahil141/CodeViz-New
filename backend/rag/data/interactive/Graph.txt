### DOCUMENT_TYPE: INTERACTIVE
### TOPIC: Graph
### NAME: Graph
### DESCRIPTION: Unified Graph Visualizer (Directed/Weighted/Undirected)

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
    body { font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; margin: 0; overflow: hidden; }
    #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #ddd; padding: 20px; display: flex; flex-direction: column; overflow-y: auto; }
    #canvas-container { flex: 1; position: relative; background: #fff; cursor: crosshair; }
    canvas { width: 100%; height: 100%; display: block; }
    h2 { margin-top: 0; font-size: 18px; color: #333; }
    .control-group { margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid #eee; }
    .control-group:last-child { border: none; }
    label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 14px; }
    select, input, button { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px; font-size: 14px; }
    button { background: #3b82f6; color: white; border: none; font-weight: 500; cursor: pointer; transition: 0.2s; }
    button:hover { background: #2563eb; }
    .mode-toggle { display: flex; gap: 5px; margin-bottom: 10px; }
    .mode-btn { flex: 1; padding: 6px; font-size: 12px; background: #eee; color: #666; border: none; cursor: pointer; }
    .mode-btn.active { background: #3b82f6; color: white; }
    .matrix-view { font-family: monospace; font-size: 12px; white-space: pre; overflow-x: auto; background: #1e293b; color: #4ade80; padding: 10px; border-radius: 4px; margin-top: 10px; }
    #node-instruction { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; pointer-events: none; font-size: 12px; }
</style>
</head>
<body>
    <div id="sidebar">
        <h2>Graph Settings</h2>
        <div class="control-group">
            <label>Type</label>
            <div class="mode-toggle">
                <button class="mode-btn active" onclick="setDirected(true)" id="btn-dir">Directed</button>
                <button class="mode-btn" onclick="setDirected(false)" id="btn-undir">Undirected</button>
            </div>
            <div class="mode-toggle">
                <button class="mode-btn active" onclick="setWeighted(false)" id="btn-unweight">Unweighted</button>
                <button class="mode-btn" onclick="setWeighted(true)" id="btn-weight">Weighted</button>
            </div>
            <button onclick="clearGraph()" style="background: #ef4444; margin-top: 10px;">Clear Graph</button>
        </div>

        <div class="control-group">
            <h2>Add Edge</h2>
            <input id="from" placeholder="From Node (ID)">
            <input id="to" placeholder="To Node (ID)">
            <input id="weight" placeholder="Weight" disabled>
            <button onclick="addEdgeManual()">Add Edge</button>
        </div>

        <div class="control-group">
            <h2>Representations</h2>
            <select id="repo-select" onchange="updateRepo()">
                <option value="matrix">Adjacency Matrix</option>
                <option value="list">Adjacency List</option>
                <option value="edges">Edge List</option>
            </select>
            <div id="repo-view" class="matrix-view"></div>
        </div>
    </div>

    <div id="canvas-container" onclick="handleCanvasClick(event)">
        <div id="node-instruction">Click on canvas to add nodes. Drag between nodes to add edge.</div>
        <canvas id="c"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        
        // State
        let nodes = []; // {id: 0, x, y}
        let edges = []; // {source, target, weight}
        let isDirected = true;
        let isWeighted = false;
        let nextId = 0;
        let selectedNode = null;
        
        // Resize
        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            draw();
        }
        window.onresize = resize;
        resize();

        function setDirected(val) {
            isDirected = val;
            document.getElementById('btn-dir').className = val ? 'mode-btn active' : 'mode-btn';
            document.getElementById('btn-undir').className = !val ? 'mode-btn active' : 'mode-btn';
            updateRepo();
            draw();
        }
        
        function setWeighted(val) {
            isWeighted = val;
            document.getElementById('weight').disabled = !val;
            document.getElementById('btn-weight').className = val ? 'mode-btn active' : 'mode-btn';
            document.getElementById('btn-unweight').className = !val ? 'mode-btn active' : 'mode-btn';
            // Default edge weights to 1 if enabling
            if(val) edges.forEach(e => e.weight = e.weight || 1);
            updateRepo();
            draw();
        }

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicked node
            const clicked = nodes.find(n => Math.hypot(n.x - x, n.y - y) < 20);
            
            if (clicked) {
                if (!selectedNode) {
                    selectedNode = clicked;
                } else {
                    // Create edge
                    if (selectedNode !== clicked) {
                        // Check exists
                        const exists = edges.find(e => 
                            (e.source === selectedNode.id && e.target === clicked.id) || 
                            (!isDirected && e.source === clicked.id && e.target === selectedNode.id)
                        );
                        if (!exists) {
                            let w = isWeighted ? prompt("Enter weight:", "1") : null;
                            if (isWeighted && w === null) { selectedNode = null; draw(); return; } // Cancelled
                            edges.push({
                                source: selectedNode.id,
                                target: clicked.id,
                                weight: isWeighted ? parseInt(w)||1 : null
                            });
                        }
                    }
                    selectedNode = null;
                }
            } else {
                // Add node
                nodes.push({ id: nextId++, x, y });
            }
            updateRepo();
            draw();
        }
        
        function addEdgeManual() {
            const f = parseInt(document.getElementById('from').value);
            const t = parseInt(document.getElementById('to').value);
            const w = parseInt(document.getElementById('weight').value) || 1;
            
            if(!nodes.find(n => n.id === f) || !nodes.find(n => n.id === t)) {
                alert("Invalid Node IDs"); return;
            }
            edges.push({ source: f, target: t, weight: isWeighted ? w : null });
            updateRepo();
            draw();
        }
        
        function clearGraph() {
            nodes = []; edges = []; nextId = 0; selectedNode = null;
            updateRepo(); draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Edges
            edges.forEach(e => {
                const s = nodes.find(n => n.id === e.source);
                const t = nodes.find(n => n.id === e.target);
                if (!s || !t) return;
                
                // Draw Line
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                ctx.lineTo(t.x, t.y);
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Arrowhead
                if (isDirected) {
                    const angle = Math.atan2(t.y - s.y, t.x - s.x);
                    const headLen = 15;
                    ctx.beginPath();
                    // Offset by radius (20)
                    const targetX = t.x - 20 * Math.cos(angle);
                    const targetY = t.y - 20 * Math.sin(angle);
                    ctx.moveTo(targetX, targetY);
                    ctx.lineTo(targetX - headLen * Math.cos(angle - Math.PI/6), targetY - headLen * Math.sin(angle - Math.PI/6));
                    ctx.lineTo(targetX - headLen * Math.cos(angle + Math.PI/6), targetY - headLen * Math.sin(angle + Math.PI/6));
                    ctx.fillStyle = '#94a3b8';
                    ctx.fill();
                }

                // Weight
                if (isWeighted) {
                    const midX = (s.x + t.x) / 2;
                    const midY = (s.y + t.y) / 2;
                    ctx.fillStyle = 'red';
                    ctx.font = '14px Arial';
                    ctx.fillText(e.weight, midX, midY - 5);
                }
            });

            // Nodes
            nodes.forEach(n => {
                ctx.beginPath();
                ctx.arc(n.x, n.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = (selectedNode === n) ? '#bfdbfe' : 'white';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = (selectedNode === n) ? '#3b82f6' : '#64748b';
                ctx.stroke();
                
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(n.id, n.x, n.y);
            });
        }
        
        function updateRepo() {
            const type = document.getElementById('repo-select').value;
            const view = document.getElementById('repo-view');
            let txt = "";
            
            if (nodes.length === 0) {
                view.textContent = "Empty Graph"; return;
            }

            if (type === 'matrix') {
                txt += "   " + nodes.map(n => n.id).join("  ") + "\n";
                nodes.forEach(rowNode => {
                    txt += rowNode.id + " [";
                    txt += nodes.map(colNode => {
                        const edge = edges.find(e => e.source === rowNode.id && e.target === colNode.id) ||
                                     (!isDirected && edges.find(e => e.source === colNode.id && e.target === rowNode.id));
                        return edge ? (isWeighted ? edge.weight : "1") : "0";
                    }).join(", ");
                    txt += "]\n";
                });
            } else if (type === 'list') {
                nodes.forEach(n => {
                    txt += `${n.id} -> `;
                    const adjs = edges.filter(e => e.source === n.id).map(e => isWeighted ? `${e.target}(${e.weight})` : e.target);
                    if (!isDirected) {
                        edges.filter(e => e.target === n.id).forEach(e => adjs.push(isWeighted ? `${e.source}(${e.weight})` : e.source));
                    }
                    txt += adjs.join(", ") + "\n";
                });
            } else {
                // Edge List
                edges.forEach(e => {
                    txt += `${e.source} -> ${e.target}`;
                    if(isWeighted) txt += ` [w=${e.weight}]`;
                    txt += "\n";
                });
            }
            view.textContent = txt;
        }
    </script>
</body>
</html>